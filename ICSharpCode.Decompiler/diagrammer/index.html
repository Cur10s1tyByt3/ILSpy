<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>ICSharpCode.Decompiler class diagrammer - ILSpy</title>
    <link rel="icon" type="image/x-icon" href="ILSpy.ico" />
    <link rel="stylesheet" href="styles.css" type="text/css" />
    <style id="filter-width"></style>
</head>
<body class="container">

    <!-- for animated background -->
    <ul class="bubbles container">
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>

    <div id="content" class="flx">
        <form id="filter" class="flx col open">
            <div class="flx gap">
                <input id="pre-filter-types" placeholder="pre-filter" class="grow"
                       title="üêã I sift through the types for you.&#10;Feed me vanilla ü¶ê plain text or ES/JS flavored üç§ RegEx.&#10;üî≠ Focus me with [Ctrl + K]. " />
                <label for="type-select" class="grow">types</label>
                <button type="button" class="icon" data-toggles="#info" title="üïØÔ∏è Shed light on the type selection"><span class="torch"></span></button>
            </div>

            <div id="info" class="scndry vertical collapse">
                <p>
                    The <big>type picker</big> is ‚úú focused when you open the app.
                    You can just <b>‚å®Ô∏è key in the first letter/s</b> of the type
                    you want to start your diagram with and <b>hit [Enter] to render</b> it.
                </p>
                <p>
                    After rendering you can üëÜ <b>tap types</b> on the diagram
                    to update your selection and redraw.
                    This allows you to <b>explore the domain</b> along relations.
                </p>
                <p>
                    Don't forget that you can hold [Shift] to <b>‚Üï range-select</b>
                    and [Ctrl] to <b>¬± add to or subtract from</b> your selection.
                </p>
                <p>
                    Note that the diagram has a üüà <b>layout direction</b> -
                    i.e. it depends on how you <b>‚áÖ sort selected types</b> using [Alt + Arrow Up|Down].
                </p>
                <p>
                    Changing the type selection or rendering options
                    updates the URL in the location bar. That means you can
                    <ul>
                        <li><b>üîñ bookmark or üì£ share the URL</b> to your diagram with whoever has access to this diagrammer,</li>
                        <li><b>access üïî earlier diagrams</b> recorded in your üßæ browser history and</li>
                        <li><b>‚á• restore your type selection</b> to the picker from the URL using ‚ü≥ Refresh [F5] if you lose it.</li>
                    </ul>
                </p>
                <h3>Looking for help with something else?</h3>
                <p>
                    <b>Stop and spot the tooltips.</b> üå∑ They'll give you more info where necessary.
                    Get a hint for elements with helping tooltips using [Alt + i].
                </p>
                <p>Alternatively, find helpful links to the docs and discussions in the
                    <a href="#build-info" class="toggle">build info <img src="ILSpy.ico" /> ‚û™</a></p>
                <p>If you find this helpful and want to share your üì∫ screen and üéì wisdom on how it works
                    with a ü¶ó newcomer, try toggling <b>presentation mode</b> using [Ctrl + i].</p>
            </div>

            <select multiple id="type-select" class="grow" title="ü•¢ pick types to include in your diagram"></select>

            <fieldset id="inheritance" class="scndry flx" title="You may find these options useful to reason about type inheritance - probably less so when looking at entity relations.">
                <legend>show inherited</legend>

                <span class="scndry flx" title="Render direct base types.">
                    <input type="checkbox" id="show-base-types" checked />
                    <label for="show-base-types">types</label>
                </span>
                <span class="scndry flx" title="Render direct interfaces.">
                    <input type="checkbox" id="show-interfaces" checked />
                    <label for="show-interfaces">interfaces</label>
                </span>
                <span class="scndry flx" title="Render members inherited from ancestor types - unless those are also selected and rendered in detail.">
                    <input type="checkbox" id="show-inherited-members" checked />
                    <label for="show-inherited-members">members</label>
                </span>
            </fieldset>

            <fieldset id="direction" class="scndry flx" title="[Ctrl + arrow keys] You may want to change this depending on your screen or printer and the size of the diagram.">
                <legend>layout direction</legend>
                <input type="radio" name="direction" value="RL" id="dir-rl" />
                <label for="dir-rl">‚Æò</label>
                <input type="radio" name="direction" value="TB" id="dir-tb" />
                <label for="dir-tb">‚Æõ</label>
                <input type="radio" name="direction" value="BT" id="dir-bt" />
                <label for="dir-bt">‚Æô</label>
                <input type="radio" name="direction" value="LR" id="dir-lr" checked />
                <label for="dir-lr">‚Æö</label>
            </fieldset>

            <div id="actions" class="flx spaced">
                <button title="Render the selected types. [Enter] with the side bar in focus will do."
                        type="submit" id="render" disabled><span class="trawl-net"></span> Cast the diagram</button>
                <button type="button" class="icon" data-toggles="#exportOptions" id="exportOptions-toggle" hidden title="toggle ü•° export options">üé£</button>
            </div>

            <div id="exportOptions" class="scndry vertical collapse aligned spaced flx gap col">

                <div class="flx gap" title="Note that you can also use your browser's Print function [Ctrl + P] to export to PDF or paper or split up the diagram into multiple pages.">
                    <button type="button" id="save" data-assembly="ICSharpCode.Decompiler" title="[Ctrl + S] Saves the diagram in the selected format using a generated name.">üíæ Save</button>
                    <label>or</label>
                    <button type="button" id="copy" title="[Ctrl + C] Copies the diagram in the selected format to your clipboard for you to paste directly into a messenger, word- or image processor.">üìã Copy to clipboard</button>
                </div>

                <div class="flx">
                    <label>as</label>
                    <span class="flx" title="Exports the diagram as SVG to render in an HTML document or SVG-enabled word processor.">
                        <input type="radio" name="saveAs" value="svg" id="saveAs-svg" />
                        <label for="saveAs-svg">svg</label>
                    </span>
                    <span class="flx" title="Exports the diagram as a base-64 encoded PNG.">
                        <input type="radio" name="saveAs" value="png" id="saveAs-png" checked />
                        <label for="saveAs-png">png</label>
                    </span>
                    <span class="flx" title="Exports the mermaid syntax for the diagram.">
                        <input type="radio" name="saveAs" value="mmd" id="saveAs-mmd" />
                        <label for="saveAs-mmd">mmd</label>
                    </span>
                </div>

                <div id="dimensions" class="vertical open collapse">
                    <fieldset title="Applied when saving and in (unscalable) image format. Note these settings indirectly determine the resolution.">
                        <legend>png dimensions</legend>

                        <div class="flx">
                            <input type="radio" name="dimension" value="auto" id="dimension-current" checked />
                            <label for="dimension-current">current</label>
                            <input type="radio" name="dimension" value="scale" id="dimension-scale" />
                            <label for="dimension-scale">scale to fixed</label>
                        </div>

                        <div id="scale-controls" class="flx aligned">
                            <input type="radio" name="scale" value="width" id="scale-width" checked disabled />
                            <label for="scale-width">width</label>
                            <input type="radio" name="scale" value="height" id="scale-height" disabled />
                            <label for="scale-height">height</label>
                            <div class="scale-size flx aligned">
                                <label for="scale-size">of</label>
                                <input type="text" id="scale-size" value="1080" disabled />
                                <label for="scale-size">px</label>
                            </div>
                        </div>
                    </fieldset>
                </div>
            </div>
        </form>

        <button type="button" class="icon" id="filter-toggle" title="üßú‚Äç‚ôÇÔ∏è Let me lay it out for you.&#10üëÜ Tap me to toggle the side bar [Ctrl + B].&#10;üëå Grab and drag me if you need ‚á¢ more space for the type selection.">‚•Ç</button>

        <div id="output" class="grow" data-title="üßú‚Äç‚ôÄÔ∏è I'm not your basic diagram.&#10;üëÜ Tap my types to toggle them.&#10;&#10;üîç Zoom me with [Ctrl + mouse wheel].&#10;üëå Grab and drag me around to pan after.&#10;üßΩ Reset zoom and pan with [Ctrl + 0]."></div>
    </div>

    <div id="about" class="flx col gap" title="üêô build info and project links">
        <div id="toaster" class="flx col gap"></div>
        <div class="build-info flx">
            <div id="build-info" class="scndry horizontal collapse flx col">
                <span>built from ICSharpCode.Decompiler v9.0.0.7867 and mermaid.js from CDN
                    <a target="_blank" href="https://cdn.jsdelivr.net/npm/mermaid@11.4.0/dist/mermaid.min.js" download="mermaid.min.js"
                        title="For off-line use, download a copy and save it in the diagrammer folder. At the bottom of the index.html you'll find a script with a reference to the mermaid CDN. Replace its 'src' with the file name of your local copy, e.g. 'mermaid.min.js'.">üì•</a>
                </span>
                <span>
                    using <a class="project" target="_blank" href="https://github.com/icsharpcode/ILSpy#readme" title="ü§ø get learned and find out about or üî± fork the project">ICSharpCode.ILSpyX</a> v9.0.0.7867-mermaid-diagrammer-preview3+b278c6ae33c4eaaf69efda798ab01e908b005b62
                    <a target="_blank" href="https://github.com/icsharpcode/ILSpy/wiki/Diagramming" title="the manual">üìú</a>
                    <a target="_blank" href="https://github.com/icsharpcode/ILSpy/discussions" title="ü§î ask questions, share and discuss üí° ideas">üí¨</a>
                    <a target="_blank" href="https://github.com/icsharpcode/ILSpy/issues" title="ü¶ü feed bugs to the fishes and request üå± new features"><span class="mano-a-borsa"></span></a>
                    <a target="_blank" href="https://github.com/icsharpcode/ILSpy/releases/latest" title="‚òÑÔ∏è download the latest bits to üåä generate better diagrammers">üå©Ô∏è</a>
                </span>
            </div>
            <img data-toggles="#build-info" src="ILSpy.ico" />
        </div>
    </div>

    <div id="pressed-keys" class="hidden"></div>
    <div id="mouse" hidden></div>

    <script id="model" type="application/json">{
  "OutsideReferences": {
    "ICSharpCode_Decompiler_TypeSystem_Implementation_TypeWithElementType": "ICSharpCode.Decompiler.TypeSystem.Implementation.TypeWithElementType",
    "System_ValueType": "System.ValueType",
    "System_IEquatable_T": "System.IEquatable\u2770T\u2771",
    "ICSharpCode_Decompiler_TypeSystem_Implementation_SimpleCompilation": "ICSharpCode.Decompiler.TypeSystem.Implementation.SimpleCompilation",
    "System_Collections_Generic_IEqualityComparer_T": "System.Collections.Generic.IEqualityComparer\u2770T\u2771",
    "ICSharpCode_Decompiler_TypeSystem_Implementation_AbstractType": "ICSharpCode.Decompiler.TypeSystem.Implementation.AbstractType",
    "System_Exception": "System.Exception",
    "System_Reflection_Metadata_ISignatureTypeProvider_TType_TGenericContext": "System.Reflection.Metadata.ISignatureTypeProvider\u2770TType, TGenericContext\u2771",
    "System_Reflection_Metadata_ISimpleTypeProvider_TType": "System.Reflection.Metadata.ISimpleTypeProvider\u2770TType\u2771",
    "System_Reflection_Metadata_IConstructedTypeProvider_TType": "System.Reflection.Metadata.IConstructedTypeProvider\u2770TType\u2771",
    "System_Reflection_Metadata_ISZArrayTypeProvider_TType": "System.Reflection.Metadata.ISZArrayTypeProvider\u2770TType\u2771",
    "System_Reflection_Metadata_ICustomAttributeTypeProvider_TType": "System.Reflection.Metadata.ICustomAttributeTypeProvider\u2770TType\u2771"
  },
  "TypesByNamespace": {
    "ICSharpCode.Decompiler.TypeSystem": {
      "Accessibility": {
        "Body": "class Accessibility {\n    \u003C\u003CEnumeration\u003E\u003E\n    None\n    Private\n    ProtectedAndInternal\n    Protected\n    Internal\n    ProtectedOrInternal\n    Public\n}",
        "XmlDocs": {
          "": "Enum that describes the accessibility of an entity.",
          "None": "The entity is completely inaccessible. This is used for C# explicit interface implementations.",
          "Private": "The entity is only accessible within the same class.",
          "ProtectedAndInternal": "The entity is accessible in derived classes within the same assembly.\r\nThis corresponds to C# [c]private protected[/c].",
          "Protected": "The entity is only accessible within the same class and in derived classes.",
          "Internal": "The entity is accessible within the same assembly.",
          "ProtectedOrInternal": "The entity is accessible both everywhere in the assembly, and in all derived classes.\r\nThis corresponds to C# [c]protected internal[/c].",
          "Public": "The entity is accessible everywhere."
        }
      },
      "AccessibilityExtensions": {
        "Body": "class AccessibilityExtensions {\n    \u002BLessThanOrEqual(Accessibility a, Accessibility b)$ bool\n    \u002BIntersect(Accessibility a, Accessibility b)$ Accessibility\n    \u002BUnion(Accessibility a, Accessibility b)$ Accessibility\n    \u002BEffectiveAccessibility(IEntity entity)$ Accessibility\n    \u003C\u003CService\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "LessThanOrEqual": "Gets whether a \u0026lt;= b in the partial order of accessibilities:\r\nreturn true if b is accessible everywhere where a is accessible.",
          "Intersect": "Computes the intersection of the two accessibilities:\r\nThe result is accessible from any given point in the code\r\niff both a and b are accessible from that point.",
          "Union": "Computes the union of the two accessibilities:\r\nThe result is accessible from any given point in the code\r\niff at least one of a or b is accessible from that point.",
          "EffectiveAccessibility": "Gets the effective accessibility of the entity.\r\nFor example, a public method in an internal class returns \u0022internal\u0022."
        }
      },
      "ApplyAttributeTypeVisitor": {
        "Body": "class ApplyAttributeTypeVisitor {\n    \u002BApplyAttributesToType(IType inputType, ICompilation compilation, CustomAttributeHandleCollection? attributes, MetadataReader metadata, TypeSystemOptions options, Nullability nullableContext, bool typeChildrenOnly, CustomAttributeHandleCollection? additionalAttributes)$ IType\n    \u002BApplyAttributesToType(IType inputType, ICompilation compilation, TypeSystemOptions options, PdbExtraTypeInfo pdbExtraTypeInfo)$ IType\n    \u002BVisitModOpt(ModifiedType type) IType\n    \u002BVisitModReq(ModifiedType type) IType\n    \u002BVisitPointerType(PointerType type) IType\n    -GetNullability() Nullability\n    -ExpectDummyNullabilityForGenericValueType() void\n    \u002BVisitArrayType(ArrayType type) IType\n    \u002BVisitByReferenceType(ByReferenceType type) IType\n    \u002BVisitParameterizedType(ParameterizedType type) IType\n    \u002BVisitFunctionPointerType(FunctionPointerType type) IType\n    \u002BVisitTypeDefinition(ITypeDefinition type) IType\n    \u002BVisitOtherType(IType type) IType\n    \u002BVisitTypeParameter(ITypeParameter type) IType\n    -ICompilation compilation\n    -bool hasDynamicAttribute\n    -bool[] dynamicAttributeData\n    -bool hasNativeIntegersAttribute\n    -bool[] nativeIntegersAttributeData\n    -TypeSystemOptions options\n    -string[] tupleElementNames\n    -Nullability defaultNullability\n    -Nullability[] nullableAttributeData\n    -int dynamicTypeIndex\n    -int tupleTypeIndex\n    -int nullabilityTypeIndex\n    -int nativeIntTypeIndex\n}",
        "BaseType": {
          "TypeVisitor": null
        },
        "Inherited": {
          "TypeVisitor": {
            "FlatMembers": "ApplyAttributeTypeVisitor : \u002BVisitTypeDefinition(ITypeDefinition type) IType\nApplyAttributeTypeVisitor : \u002BVisitTypeParameter(ITypeParameter type) IType\nApplyAttributeTypeVisitor : \u002BVisitParameterizedType(ParameterizedType type) IType\nApplyAttributeTypeVisitor : \u002BVisitArrayType(ArrayType type) IType\nApplyAttributeTypeVisitor : \u002BVisitPointerType(PointerType type) IType\nApplyAttributeTypeVisitor : \u002BVisitByReferenceType(ByReferenceType type) IType\nApplyAttributeTypeVisitor : \u002BVisitTupleType(TupleType type) IType\nApplyAttributeTypeVisitor : \u002BVisitOtherType(IType type) IType\nApplyAttributeTypeVisitor : \u002BVisitModReq(ModifiedType type) IType\nApplyAttributeTypeVisitor : \u002BVisitModOpt(ModifiedType type) IType\nApplyAttributeTypeVisitor : \u002BVisitNullabilityAnnotatedType(NullabilityAnnotatedType type) IType\nApplyAttributeTypeVisitor : \u002BVisitFunctionPointerType(FunctionPointerType type) IType"
          }
        },
        "XmlDocs": {
          "": "Introduces \u0027dynamic\u0027 and tuple types based on attribute values."
        }
      },
      "ArrayType": {
        "Body": "class ArrayType {\n    \u002Bint Dimensions\n    \u002Bstring NameSuffix\n    \u002Bbool? IsReferenceType\n    \u002BChangeNullability(Nullability nullability) IType\n    \u002BGetHashCode() int\n    \u002BEquals(IType other) bool\n    \u002BToString() string\n    \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options) IEnumerable\u2770IProperty\u2771\n    \u002BAcceptVisitor(TypeVisitor visitor) IType\n    \u002BVisitChildren(TypeVisitor visitor) IType\n}",
        "BaseType": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_TypeWithElementType": null
        },
        "Interfaces": {
          "ICompilationProvider": [
            null
          ]
        },
        "Inherited": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_AbstractType": {
            "FlatMembers": "ArrayType : \u002Bstring FullName\nArrayType : \u002Bstring Name*\nArrayType : \u002Bstring Namespace\nArrayType : \u002Bstring ReflectionName\nArrayType : \u002Bbool? IsReferenceType*\nArrayType : \u002Bbool IsByRefLike\nArrayType : \u002Bint TypeParameterCount\nArrayType : \u002BChangeNullability(Nullability nullability) IType\nArrayType : \u002BGetDefinition() ITypeDefinition\nArrayType : \u002BGetDefinitionOrUnknown() ITypeDefinitionOrUnknown\nArrayType : \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nArrayType : \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nArrayType : \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nArrayType : \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nArrayType : \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nArrayType : \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options) IEnumerable\u2770IProperty\u2771\nArrayType : \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options) IEnumerable\u2770IField\u2771\nArrayType : \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options) IEnumerable\u2770IEvent\u2771\nArrayType : \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMember\u2771\nArrayType : \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nArrayType : \u002BGetSubstitution() TypeParameterSubstitution\nArrayType : \u002BGetSubstitution(IReadOnlyList\u2770IType\u2771 methodTypeArguments) TypeParameterSubstitution\nArrayType : \u002BEquals(IType other) bool\nArrayType : \u002BAcceptVisitor(TypeVisitor visitor) IType\nArrayType : \u002BVisitChildren(TypeVisitor visitor) IType",
            "HasOne": {
              "Nullability": "Nullability",
              "Kind": "TypeKind",
              "DeclaringType": "IType"
            },
            "HasMany": {
              "TypeParameters": "ITypeParameter",
              "TypeArguments": "IType",
              "DirectBaseTypes": "IType"
            }
          },
          "ICSharpCode_Decompiler_TypeSystem_Implementation_TypeWithElementType": {
            "FlatMembers": "ArrayType : \u002Bstring Name\nArrayType : \u002Bstring Namespace\nArrayType : \u002Bstring FullName\nArrayType : \u002Bstring ReflectionName\nArrayType : \u002Bstring NameSuffix*\nArrayType : \u002BToString() string\nArrayType : \u002BVisitChildren(TypeVisitor visitor)* IType",
            "HasOne": {
              "ElementType": "IType"
            }
          }
        },
        "XmlDocs": {
          "": "Represents an array type."
        },
        "HasOne": {
          "Kind": "TypeKind",
          "Compilation": "ICompilation",
          "Nullability": "Nullability"
        },
        "HasMany": {
          "DirectBaseTypes": "IType"
        }
      },
      "ArrayTypeReference": {
        "Body": "class ArrayTypeReference {\n    \u002Bint Dimensions\n    \u002BResolve(ITypeResolveContext context) IType\n    \u002BToString() string\n    -ISupportsInterning.GetHashCodeForInterning() int\n    -ISupportsInterning.EqualsForInterning(ISupportsInterning other) bool\n}",
        "Interfaces": {
          "ITypeReference": [
            null
          ],
          "ISupportsInterning": [
            null
          ]
        },
        "Inherited": {},
        "HasOne": {
          "ElementType": "ITypeReference"
        }
      },
      "AssemblyQualifiedTypeName": {
        "Body": "class AssemblyQualifiedTypeName {\n    \u002BToString() string\n    \u002BEquals(object obj) bool\n    \u002BEquals(AssemblyQualifiedTypeName other) bool\n    \u002BGetHashCode() int\n    \u002Bstring AssemblyName\n    \u002BFullTypeName TypeName\n}",
        "BaseType": {
          "System_ValueType": null
        },
        "Interfaces": {
          "System_IEquatable_T": [
            "IEquatable\u2770AssemblyQualifiedTypeName\u2771"
          ]
        },
        "Inherited": {
          "System_ValueType": {
            "FlatMembers": "AssemblyQualifiedTypeName : -CanCompareBits(object obj)$ bool\nAssemblyQualifiedTypeName : -FastEqualsCheck(object a, object b)$ bool\nAssemblyQualifiedTypeName : ~GetHashCodeOfPtr(IntPtr ptr)$ int"
          }
        }
      },
      "ByReferenceType": {
        "Body": "class ByReferenceType {\n    \u002Bstring NameSuffix\n    \u002Bbool? IsReferenceType\n    \u002Bbool IsByRefLike\n    \u002BGetHashCode() int\n    \u002BEquals(IType other) bool\n    \u002BAcceptVisitor(TypeVisitor visitor) IType\n    \u002BVisitChildren(TypeVisitor visitor) IType\n}",
        "BaseType": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_TypeWithElementType": null
        },
        "Inherited": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_AbstractType": {
            "FlatMembers": "ByReferenceType : \u002Bstring FullName\nByReferenceType : \u002Bstring Name*\nByReferenceType : \u002Bstring Namespace\nByReferenceType : \u002Bstring ReflectionName\nByReferenceType : \u002Bbool? IsReferenceType*\nByReferenceType : \u002Bbool IsByRefLike\nByReferenceType : \u002Bint TypeParameterCount\nByReferenceType : \u002BChangeNullability(Nullability nullability) IType\nByReferenceType : \u002BGetDefinition() ITypeDefinition\nByReferenceType : \u002BGetDefinitionOrUnknown() ITypeDefinitionOrUnknown\nByReferenceType : \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nByReferenceType : \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nByReferenceType : \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nByReferenceType : \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nByReferenceType : \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nByReferenceType : \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options) IEnumerable\u2770IProperty\u2771\nByReferenceType : \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options) IEnumerable\u2770IField\u2771\nByReferenceType : \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options) IEnumerable\u2770IEvent\u2771\nByReferenceType : \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMember\u2771\nByReferenceType : \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nByReferenceType : \u002BGetSubstitution() TypeParameterSubstitution\nByReferenceType : \u002BGetSubstitution(IReadOnlyList\u2770IType\u2771 methodTypeArguments) TypeParameterSubstitution\nByReferenceType : \u002BEquals(IType other) bool\nByReferenceType : \u002BAcceptVisitor(TypeVisitor visitor) IType\nByReferenceType : \u002BVisitChildren(TypeVisitor visitor) IType",
            "HasOne": {
              "Nullability": "Nullability",
              "Kind": "TypeKind",
              "DeclaringType": "IType"
            },
            "HasMany": {
              "TypeParameters": "ITypeParameter",
              "TypeArguments": "IType",
              "DirectBaseTypes": "IType"
            }
          },
          "ICSharpCode_Decompiler_TypeSystem_Implementation_TypeWithElementType": {
            "FlatMembers": "ByReferenceType : \u002Bstring Name\nByReferenceType : \u002Bstring Namespace\nByReferenceType : \u002Bstring FullName\nByReferenceType : \u002Bstring ReflectionName\nByReferenceType : \u002Bstring NameSuffix*\nByReferenceType : \u002BToString() string\nByReferenceType : \u002BVisitChildren(TypeVisitor visitor)* IType",
            "HasOne": {
              "ElementType": "IType"
            }
          }
        },
        "HasOne": {
          "Kind": "TypeKind"
        }
      },
      "ByReferenceTypeReference": {
        "Body": "class ByReferenceTypeReference {\n    \u002BResolve(ITypeResolveContext context) IType\n    \u002BToString() string\n    -ISupportsInterning.GetHashCodeForInterning() int\n    -ISupportsInterning.EqualsForInterning(ISupportsInterning other) bool\n}",
        "Interfaces": {
          "ITypeReference": [
            null
          ],
          "ISupportsInterning": [
            null
          ]
        },
        "Inherited": {},
        "HasOne": {
          "ElementType": "ITypeReference"
        }
      },
      "ComHelper": {
        "Body": "class ComHelper {\n    \u002BIsComImport(ITypeDefinition typeDefinition)$ bool\n    \u002BGetCoClass(ITypeDefinition typeDefinition)$ IType\n    \u003C\u003CService\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Helper methods for COM.",
          "IsComImport": "Gets whether the specified type is imported from COM.",
          "GetCoClass": "Gets the CoClass of the specified COM interface."
        }
      },
      "DecompilerTypeSystem": {
        "Body": "class DecompilerTypeSystem {\n    \u002BGetOptions(DecompilerSettings settings)$ TypeSystemOptions\n    \u002BCreateAsync(PEFile mainModule, IAssemblyResolver assemblyResolver)$ Task\u2770DecompilerTypeSystem\u2771\n    \u002BCreateAsync(PEFile mainModule, IAssemblyResolver assemblyResolver, DecompilerSettings settings)$ Task\u2770DecompilerTypeSystem\u2771\n    \u002BCreateAsync(PEFile mainModule, IAssemblyResolver assemblyResolver, TypeSystemOptions typeSystemOptions)$ Task\u2770DecompilerTypeSystem\u2771\n    -InitializeAsync(MetadataFile mainModule, IAssemblyResolver assemblyResolver, TypeSystemOptions typeSystemOptions) Task\n    -string[] implicitReferences$\n}",
        "BaseType": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_SimpleCompilation": null
        },
        "Interfaces": {
          "IDecompilerTypeSystem": [
            null
          ],
          "ICompilation": [
            null
          ]
        },
        "Inherited": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_SimpleCompilation": {
            "FlatMembers": "DecompilerTypeSystem : \u002BCacheManager CacheManager\nDecompilerTypeSystem : \u002BStringComparer NameComparer\nDecompilerTypeSystem : #Init(IModuleReference mainAssembly, IEnumerable\u2770IModuleReference\u2771 assemblyReferences) void\nDecompilerTypeSystem : #CreateRootNamespace() INamespace\nDecompilerTypeSystem : \u002BGetNamespaceForExternAlias(string alias) INamespace\nDecompilerTypeSystem : \u002BFindType(KnownTypeCode typeCode) IType\nDecompilerTypeSystem : -KnownTypeCache knownTypeCache\nDecompilerTypeSystem : -IReadOnlyList\u2770IModule\u2771 assemblies\nDecompilerTypeSystem : -IReadOnlyList\u2770IModule\u2771 referencedAssemblies\nDecompilerTypeSystem : -bool initialized",
            "HasOne": {
              "MainModule": "IModule",
              "RootNamespace": "INamespace"
            },
            "HasMany": {
              "Modules": "IModule",
              "ReferencedModules": "IModule"
            }
          }
        },
        "XmlDocs": {
          "": "Manages the NRefactory type system for the decompiler.\r\n\r\n[remarks]\r\nThis class is thread-safe.\r\n[/remarks]"
        },
        "HasOne": {
          "MainModule": "MetadataModule"
        }
      },
      "FullTypeName": {
        "Body": "class FullTypeName {\n    \u002Bbool IsNested\n    \u002Bint NestingLevel\n    \u002Bstring Name\n    \u002Bstring ReflectionName\n    \u002Bstring FullName\n    \u002Bint TypeParameterCount\n    \u002BGetNestedTypeName(int nestingLevel) string\n    \u002BGetNestedTypeAdditionalTypeParameterCount(int nestingLevel) int\n    \u002BGetDeclaringType() FullTypeName\n    \u002BNestedType(string name, int additionalTypeParameterCount) FullTypeName\n    \u002BToString() string\n    \u002BEquals(object obj) bool\n    \u002BEquals(FullTypeName other) bool\n    \u002BGetHashCode() int\n    -TopLevelTypeName topLevelType\n    -FullTypeName\u002BNestedTypeName[] nestedTypes\n}",
        "BaseType": {
          "System_ValueType": null
        },
        "Interfaces": {
          "System_IEquatable_T": [
            "IEquatable\u2770FullTypeName\u2771"
          ]
        },
        "Inherited": {
          "System_ValueType": {
            "FlatMembers": "FullTypeName : -CanCompareBits(object obj)$ bool\nFullTypeName : -FastEqualsCheck(object a, object b)$ bool\nFullTypeName : ~GetHashCodeOfPtr(IntPtr ptr)$ int"
          }
        },
        "XmlDocs": {
          "": "Holds the full name of a type definition.\r\nA full type name uniquely identifies a type definition within a single assembly.\r\n\r\n[remarks]\r\nA full type name can only represent type definitions, not arbitrary types.\r\nIt does not include any type arguments, and can not refer to array or pointer types.\r\n\r\nA full type name represented as reflection name has the syntax:\r\n[c]NamespaceName \u0027.\u0027 TopLevelTypeName [\u0027\u0060\u0027#] { \u0027\u002B\u0027 NestedTypeName [\u0027\u0060\u0027#] }[/c]\r\n[/remarks]",
          "TopLevelTypeName": "Gets the top-level type name.",
          "IsNested": "Gets whether this is a nested type.",
          "NestingLevel": "Gets the nesting level.",
          "Name": "Gets the name of the type.\r\nFor nested types, this is the name of the innermost type.",
          "TypeParameterCount": "Gets the total type parameter count.",
          "GetNestedTypeName": "Gets the name of the nested type at the given level.",
          "GetNestedTypeAdditionalTypeParameterCount": "Gets the number of additional type parameters of the nested type at the given level.",
          "GetDeclaringType": "Gets the declaring type name.\r\n\r\n[exception cref=\u0022T:System.InvalidOperationException\u0022]This is a top-level type name.[/exception]\r\n[example][c]new FullTypeName(\u0022NS.A\u002BB\u002BC\u0022).GetDeclaringType()[/c] will return [c]new FullTypeName(\u0022NS.A\u002BB\u0022)[/c][/example]",
          "NestedType": "Creates a nested type name.\r\n\r\n[example][c]new FullTypeName(\u0022NS.A\u002BB\u0022).NestedType(\u0022C\u0022, 1)[/c] will return [c]new FullTypeName(\u0022NS.A\u002BB\u002BC\u00601\u0022)[/c][/example]"
        },
        "HasOne": {
          "TopLevelTypeName": "TopLevelTypeName"
        }
      },
      "NestedTypeName": {
        "Name": "FullTypeName\u002BNestedTypeName",
        "Body": "class NestedTypeName {\n    \u002Bstring Name\n    \u002Bint AdditionalTypeParameterCount\n}",
        "BaseType": {
          "System_ValueType": null
        },
        "Inherited": {
          "System_ValueType": {
            "FlatMembers": "NestedTypeName : -CanCompareBits(object obj)$ bool\nNestedTypeName : -FastEqualsCheck(object a, object b)$ bool\nNestedTypeName : ~GetHashCodeOfPtr(IntPtr ptr)$ int"
          }
        }
      },
      "FullTypeNameComparer": {
        "Body": "class FullTypeNameComparer {\n    \u002BEquals(FullTypeName x, FullTypeName y) bool\n    \u002BGetHashCode(FullTypeName obj) int\n    \u002BFullTypeNameComparer Ordinal$\n    \u002BFullTypeNameComparer OrdinalIgnoreCase$\n    \u002BStringComparer NameComparer\n}",
        "Interfaces": {
          "System_Collections_Generic_IEqualityComparer_T": [
            "IEqualityComparer\u2770FullTypeName\u2771"
          ]
        },
        "Inherited": {}
      },
      "FunctionPointerType": {
        "Body": "class FunctionPointerType {\n    \u002Bstring Name\n    \u002Bbool? IsReferenceType\n    \u002BFromSignature(MethodSignature\u2770IType\u2771 signature, MetadataModule module)$ FunctionPointerType\n    \u002BGetDefinition() ITypeDefinition\n    \u002BGetDefinitionOrUnknown() ITypeDefinitionOrUnknown\n    \u002BAcceptVisitor(TypeVisitor visitor) IType\n    \u002BVisitChildren(TypeVisitor visitor) IType\n    \u002BEquals(IType other) bool\n    \u002BGetHashCode() int\n    ~WithSignature(IType returnType, ImmutableArray\u2770IType\u2771 parameterTypes) IType\n    -MetadataModule module\n    \u002BSignatureCallingConvention CallingConvention\n    \u002BImmutableArray\u2770IType\u2771 CustomCallingConventions\n    \u002BIType ReturnType\n    \u002Bbool ReturnIsRefReadOnly\n    \u002BImmutableArray\u2770IType\u2771 ParameterTypes\n    \u002BImmutableArray\u2770ReferenceKind\u2771 ParameterReferenceKinds\n}",
        "BaseType": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_AbstractType": null
        },
        "Inherited": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_AbstractType": {
            "FlatMembers": "FunctionPointerType : \u002Bstring FullName\nFunctionPointerType : \u002Bstring Name*\nFunctionPointerType : \u002Bstring Namespace\nFunctionPointerType : \u002Bstring ReflectionName\nFunctionPointerType : \u002Bbool? IsReferenceType*\nFunctionPointerType : \u002Bbool IsByRefLike\nFunctionPointerType : \u002Bint TypeParameterCount\nFunctionPointerType : \u002BChangeNullability(Nullability nullability) IType\nFunctionPointerType : \u002BGetDefinition() ITypeDefinition\nFunctionPointerType : \u002BGetDefinitionOrUnknown() ITypeDefinitionOrUnknown\nFunctionPointerType : \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nFunctionPointerType : \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nFunctionPointerType : \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nFunctionPointerType : \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nFunctionPointerType : \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nFunctionPointerType : \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options) IEnumerable\u2770IProperty\u2771\nFunctionPointerType : \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options) IEnumerable\u2770IField\u2771\nFunctionPointerType : \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options) IEnumerable\u2770IEvent\u2771\nFunctionPointerType : \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMember\u2771\nFunctionPointerType : \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nFunctionPointerType : \u002BGetSubstitution() TypeParameterSubstitution\nFunctionPointerType : \u002BGetSubstitution(IReadOnlyList\u2770IType\u2771 methodTypeArguments) TypeParameterSubstitution\nFunctionPointerType : \u002BEquals(IType other) bool\nFunctionPointerType : \u002BAcceptVisitor(TypeVisitor visitor) IType\nFunctionPointerType : \u002BVisitChildren(TypeVisitor visitor) IType",
            "HasOne": {
              "Nullability": "Nullability",
              "Kind": "TypeKind",
              "DeclaringType": "IType"
            },
            "HasMany": {
              "TypeParameters": "ITypeParameter",
              "TypeArguments": "IType",
              "DirectBaseTypes": "IType"
            }
          }
        },
        "HasOne": {
          "Kind": "TypeKind"
        }
      },
      "GenericContext": {
        "Body": "class GenericContext {\n    \u002BGetClassTypeParameter(int index) ITypeParameter\n    \u002BGetMethodTypeParameter(int index) ITypeParameter\n    ~ToSubstitution() TypeParameterSubstitution\n    \u002BIReadOnlyList\u2770ITypeParameter\u2771 ClassTypeParameters\n    \u002BIReadOnlyList\u2770ITypeParameter\u2771 MethodTypeParameters\n}",
        "BaseType": {
          "System_ValueType": null
        },
        "Inherited": {
          "System_ValueType": {
            "FlatMembers": "GenericContext : -CanCompareBits(object obj)$ bool\nGenericContext : -FastEqualsCheck(object a, object b)$ bool\nGenericContext : ~GetHashCodeOfPtr(IntPtr ptr)$ int"
          }
        }
      },
      "GetMemberOptions": {
        "Body": "class GetMemberOptions {\n    \u003C\u003CEnumeration\u003E\u003E\n    None\n    ReturnMemberDefinitions\n    IgnoreInheritedMembers\n}",
        "XmlDocs": {
          "None": "No options specified - this is the default.\r\nMembers will be specialized, and inherited members will be included.",
          "ReturnMemberDefinitions": "Do not specialize the returned members - directly return the definitions.",
          "IgnoreInheritedMembers": "Do not list inherited members - only list members defined directly on this type."
        }
      },
      "IAttribute": {
        "Body": "class IAttribute {\n    \u002BIType AttributeType*\n    \u002BIMethod Constructor*\n    \u002Bbool HasDecodeErrors*\n    \u002BImmutableArray\u2770CustomAttributeTypedArgument\u2770IType\u2771\u2771 FixedArguments*\n    \u002BImmutableArray\u2770CustomAttributeNamedArgument\u2770IType\u2771\u2771 NamedArguments*\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Represents an attribute.",
          "AttributeType": "Gets the type of the attribute.",
          "Constructor": "Gets the constructor being used.\r\nThis property may return null if no matching constructor was found.",
          "HasDecodeErrors": "Gets whether there were errors decoding the attribute.",
          "FixedArguments": "Gets the positional arguments.",
          "NamedArguments": "Gets the named arguments passed to the attribute."
        }
      },
      "ICodeContext": {
        "Body": "class ICodeContext {\n    \u002BIEnumerable\u2770IVariable\u2771 LocalVariables*\n    \u002Bbool IsWithinLambdaExpression*\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "ITypeResolveContext": [
            null
          ],
          "ICompilationProvider": [
            null
          ]
        },
        "Inherited": {
          "ICompilationProvider": {
            "FlatMembers": "ICodeContext : \u002BICompilation Compilation*"
          },
          "ITypeResolveContext": {
            "FlatMembers": "ICodeContext : \u002BIModule CurrentModule*\nICodeContext : \u002BITypeDefinition CurrentTypeDefinition*\nICodeContext : \u002BIMember CurrentMember*\nICodeContext : \u002BWithCurrentTypeDefinition(ITypeDefinition typeDefinition)* ITypeResolveContext\nICodeContext : \u002BWithCurrentMember(IMember member)* ITypeResolveContext"
          }
        },
        "XmlDocs": {
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null.",
          "CurrentModule": "Gets the current module.\r\nThis property may return null if this context does not specify any module.",
          "CurrentTypeDefinition": "Gets the current type definition.",
          "CurrentMember": "Gets the current member.",
          "LocalVariables": "Gets all currently visible local variables and lambda parameters.\r\nDoes not include method parameters.",
          "IsWithinLambdaExpression": "Gets whether the context is within a lambda expression or anonymous method."
        }
      },
      "ICompilation": {
        "Body": "class ICompilation {\n    \u002BIModule MainModule*\n    \u002BIReadOnlyList\u2770IModule\u2771 Modules*\n    \u002BIReadOnlyList\u2770IModule\u2771 ReferencedModules*\n    \u002BINamespace RootNamespace*\n    \u002BStringComparer NameComparer*\n    \u002BCacheManager CacheManager*\n    \u002BGetNamespaceForExternAlias(string alias)* INamespace\n    \u002BFindType(KnownTypeCode typeCode)* IType\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "MainModule": "Gets the primary module.\r\nThis is the module being (de)compiled; all other modules in the compilation are the other assemblies/modules\r\nreferenced by the main module.",
          "Modules": "Gets the list of all modules in the compilation.\r\n\r\n[remarks]\r\nThis main module is the first entry in the list.\r\n[/remarks]",
          "ReferencedModules": "Gets the referenced modules.\r\nThis list does not include the main module.",
          "RootNamespace": "Gets the root namespace of this compilation.\r\nThis is a merged version of the root namespaces of all assemblies.\r\n\r\n[remarks]\r\nThis always is the namespace without a name - it\u0027s unrelated to the \u0027root namespace\u0027 project setting.\r\n[/remarks]",
          "NameComparer": "Gets the name comparer for the language being compiled.\r\nThis is the string comparer used for the INamespace.GetTypeDefinition method.",
          "GetNamespaceForExternAlias": "Gets the root namespace for a given extern alias.\r\n\r\n[remarks]\r\nIf [alias] is [c]null[/c] or an empty string, this method\r\nreturns the global root namespace.\r\nIf no alias with the specified name exists, this method returns null.\r\n[/remarks]"
        }
      },
      "ICompilationProvider": {
        "Body": "class ICompilationProvider {\n    \u002BICompilation Compilation*\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null."
        }
      },
      "IDecompilerTypeSystem": {
        "Body": "class IDecompilerTypeSystem {\n    \u002BMetadataModule MainModule*\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "ICompilation": [
            null
          ]
        },
        "Inherited": {
          "ICompilation": {
            "FlatMembers": "IDecompilerTypeSystem : \u002BIModule MainModule*\nIDecompilerTypeSystem : \u002BIReadOnlyList\u2770IModule\u2771 Modules*\nIDecompilerTypeSystem : \u002BIReadOnlyList\u2770IModule\u2771 ReferencedModules*\nIDecompilerTypeSystem : \u002BINamespace RootNamespace*\nIDecompilerTypeSystem : \u002BStringComparer NameComparer*\nIDecompilerTypeSystem : \u002BCacheManager CacheManager*\nIDecompilerTypeSystem : \u002BGetNamespaceForExternAlias(string alias)* INamespace\nIDecompilerTypeSystem : \u002BFindType(KnownTypeCode typeCode)* IType"
          }
        },
        "XmlDocs": {
          "": "Main interface for the decompiler type system.\r\n\r\nThe MetadataModule class allows decoding/resolving metadata tokens into type system entities.",
          "MainModule": "Gets the primary module.\r\nThis is the module being (de)compiled; all other modules in the compilation are the other assemblies/modules\r\nreferenced by the main module.",
          "Modules": "Gets the list of all modules in the compilation.\r\n\r\n[remarks]\r\nThis main module is the first entry in the list.\r\n[/remarks]",
          "ReferencedModules": "Gets the referenced modules.\r\nThis list does not include the main module.",
          "RootNamespace": "Gets the root namespace of this compilation.\r\nThis is a merged version of the root namespaces of all assemblies.\r\n\r\n[remarks]\r\nThis always is the namespace without a name - it\u0027s unrelated to the \u0027root namespace\u0027 project setting.\r\n[/remarks]",
          "NameComparer": "Gets the name comparer for the language being compiled.\r\nThis is the string comparer used for the INamespace.GetTypeDefinition method.",
          "GetNamespaceForExternAlias": "Gets the root namespace for a given extern alias.\r\n\r\n[remarks]\r\nIf [alias] is [c]null[/c] or an empty string, this method\r\nreturns the global root namespace.\r\nIf no alias with the specified name exists, this method returns null.\r\n[/remarks]"
        }
      },
      "IEntity": {
        "Body": "class IEntity {\n    \u002BEntityHandle MetadataToken*\n    \u002Bstring Name*\n    \u002BITypeDefinition DeclaringTypeDefinition*\n    \u002BIType DeclaringType*\n    \u002BIModule ParentModule*\n    \u002Bbool IsStatic*\n    \u002Bbool IsAbstract*\n    \u002Bbool IsSealed*\n    \u002BGetAttributes()* IEnumerable\u2770IAttribute\u2771\n    \u002BHasAttribute(KnownAttribute attribute)* bool\n    \u002BGetAttribute(KnownAttribute attribute)* IAttribute\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "ISymbol": [
            null
          ],
          "ICompilationProvider": [
            null
          ],
          "INamedElement": [
            null
          ]
        },
        "Inherited": {
          "ISymbol": {
            "FlatMembers": "IEntity : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          },
          "ICompilationProvider": {
            "FlatMembers": "IEntity : \u002BICompilation Compilation*"
          },
          "INamedElement": {
            "FlatMembers": "IEntity : \u002Bstring FullName*\nIEntity : \u002Bstring Name*\nIEntity : \u002Bstring ReflectionName*\nIEntity : \u002Bstring Namespace*"
          }
        },
        "XmlDocs": {
          "": "Represents a resolved entity.",
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Name": "Gets the short name of the entity.",
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null.",
          "FullName": "Gets the fully qualified name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Collections.Generic.List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment.SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "ReflectionName": "Gets the full reflection name of the element.\r\n\r\n[remarks]\r\nFor types, the reflection name can be parsed back into a ITypeReference by using\r\n[ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)].\r\n[/remarks]\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Int32[][,]\u0022 for C# int[,][][br /]\r\n\u0022System.Collections.Generic.List\u00601[[System.String]]\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment\u002BSpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Namespace": "Gets the full name of the namespace containing this entity.",
          "MetadataToken": "Gets the metadata token for this entity.\r\n\r\n[remarks]\r\nThe token is only valid within the context of the assembly defining this entity.\r\nToken may be 0 if this is a generated member.\r\nNote: specialized members will return the token of the member definition.\r\n[/remarks]",
          "DeclaringTypeDefinition": "Gets the declaring class.\r\nFor members, this is the class that contains the member.\r\nFor nested classes, this is the outer class. For top-level entities, this property returns null.",
          "DeclaringType": "Gets/Sets the declaring type (incl. type arguments, if any).\r\nThis property will return null for top-level entities.\r\nIf this is not a specialized member, the value returned is equal to [ICSharpCode.Decompiler.TypeSystem.IEntity.DeclaringTypeDefinition].",
          "ParentModule": "The module in which this entity is defined.\r\nMay return null, if the IEntity was not created from a module.",
          "Accessibility": "Gets the accessibility of this entity.",
          "IsStatic": "Gets whether this entity is static.\r\nReturns true if either the \u0027static\u0027 or the \u0027const\u0027 modifier is set.",
          "IsAbstract": "Returns whether this entity is abstract.\r\n\r\n[remarks]Static classes also count as abstract classes.[/remarks]",
          "IsSealed": "Returns whether this entity is sealed.\r\n\r\n[remarks]Static classes also count as sealed classes.[/remarks]",
          "GetAttributes": "Gets the attributes on this entity.\r\nDoes not include inherited attributes."
        },
        "HasOne": {
          "Accessibility": "Accessibility"
        }
      },
      "IEvent": {
        "Body": "class IEvent {\n    \u002Bbool CanAdd*\n    \u002Bbool CanRemove*\n    \u002Bbool CanInvoke*\n    \u002BIMethod AddAccessor*\n    \u002BIMethod RemoveAccessor*\n    \u002BIMethod InvokeAccessor*\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "IMember": [
            null
          ],
          "IEntity": [
            null
          ],
          "ISymbol": [
            null
          ],
          "ICompilationProvider": [
            null
          ],
          "INamedElement": [
            null
          ]
        },
        "Inherited": {
          "ISymbol": {
            "FlatMembers": "IEvent : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          },
          "ICompilationProvider": {
            "FlatMembers": "IEvent : \u002BICompilation Compilation*"
          },
          "INamedElement": {
            "FlatMembers": "IEvent : \u002Bstring FullName*\nIEvent : \u002Bstring Name*\nIEvent : \u002Bstring ReflectionName*\nIEvent : \u002Bstring Namespace*"
          },
          "IEntity": {
            "FlatMembers": "IEvent : \u002BEntityHandle MetadataToken*\nIEvent : \u002Bstring Name*\nIEvent : \u002BITypeDefinition DeclaringTypeDefinition*\nIEvent : \u002BIType DeclaringType*\nIEvent : \u002BIModule ParentModule*\nIEvent : \u002Bbool IsStatic*\nIEvent : \u002Bbool IsAbstract*\nIEvent : \u002Bbool IsSealed*\nIEvent : \u002BGetAttributes()* IEnumerable\u2770IAttribute\u2771\nIEvent : \u002BHasAttribute(KnownAttribute attribute)* bool\nIEvent : \u002BGetAttribute(KnownAttribute attribute)* IAttribute",
            "HasOne": {
              "Accessibility": "Accessibility"
            }
          },
          "IMember": {
            "FlatMembers": "IEvent : \u002BIMember MemberDefinition*\nIEvent : \u002BIType ReturnType*\nIEvent : \u002BIType DeclaringType*\nIEvent : \u002BIEnumerable\u2770IMember\u2771 ExplicitlyImplementedInterfaceMembers*\nIEvent : \u002Bbool IsExplicitInterfaceImplementation*\nIEvent : \u002Bbool IsVirtual*\nIEvent : \u002Bbool IsOverride*\nIEvent : \u002Bbool IsOverridable*\nIEvent : \u002BTypeParameterSubstitution Substitution*\nIEvent : \u002BSpecialize(TypeParameterSubstitution substitution)* IMember\nIEvent : \u002BEquals(IMember obj, TypeVisitor typeNormalization)* bool"
          }
        },
        "XmlDocs": {
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Name": "Gets the short name of the entity.",
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null.",
          "FullName": "Gets the fully qualified name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Collections.Generic.List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment.SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "ReflectionName": "Gets the full reflection name of the element.\r\n\r\n[remarks]\r\nFor types, the reflection name can be parsed back into a ITypeReference by using\r\n[ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)].\r\n[/remarks]\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Int32[][,]\u0022 for C# int[,][][br /]\r\n\u0022System.Collections.Generic.List\u00601[[System.String]]\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment\u002BSpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Namespace": "Gets the full name of the namespace containing this entity.",
          "MetadataToken": "Gets the metadata token for this entity.\r\n\r\n[remarks]\r\nThe token is only valid within the context of the assembly defining this entity.\r\nToken may be 0 if this is a generated member.\r\nNote: specialized members will return the token of the member definition.\r\n[/remarks]",
          "DeclaringTypeDefinition": "Gets the declaring class.\r\nFor members, this is the class that contains the member.\r\nFor nested classes, this is the outer class. For top-level entities, this property returns null.",
          "DeclaringType": "Gets/Sets the declaring type (incl. type arguments, if any).\r\nIf this is not a specialized member, the value returned is equal to [ICSharpCode.Decompiler.TypeSystem.IEntity.DeclaringTypeDefinition].",
          "ParentModule": "The module in which this entity is defined.\r\nMay return null, if the IEntity was not created from a module.",
          "Accessibility": "Gets the accessibility of this entity.",
          "IsStatic": "Gets whether this entity is static.\r\nReturns true if either the \u0027static\u0027 or the \u0027const\u0027 modifier is set.",
          "IsAbstract": "Returns whether this entity is abstract.\r\n\r\n[remarks]Static classes also count as abstract classes.[/remarks]",
          "IsSealed": "Returns whether this entity is sealed.\r\n\r\n[remarks]Static classes also count as sealed classes.[/remarks]",
          "MemberDefinition": "Gets the original member definition for this member.\r\nReturns [c]this[/c] if this is not a specialized member.\r\nSpecialized members are the result of overload resolution with type substitution.",
          "ReturnType": "Gets the return type of this member.\r\nThis property never returns [c]null[/c].",
          "ExplicitlyImplementedInterfaceMembers": "Gets the interface members explicitly implemented by this member.\r\n\r\n[remarks]\r\nFor methods, equivalent to (\r\nfrom impl in DeclaringTypeDefinition.GetExplicitInterfaceImplementations()\r\nwhere impl.Implementation == this\r\nselect impl.InterfaceMethod\r\n),\r\nbut may be more efficient than searching the whole list.\r\n\r\nNote that it is possible for a class to implement an interface using members in a\r\nbase class unrelated to that interface:\r\nclass BaseClass { public void Dispose() {} }\r\nclass C : BaseClass, IDisposable { }\r\nIn this case, the interface member will not show up in (BaseClass.Dispose).ImplementedInterfaceMembers,\r\nso use (C).GetInterfaceImplementations() instead to handle this case.\r\n[/remarks]",
          "IsExplicitInterfaceImplementation": "Gets whether this member is explicitly implementing an interface.",
          "IsVirtual": "Gets if the member is virtual. Is true only if the \u0022virtual\u0022 modifier was used, but non-virtual\r\nmembers can be overridden, too; if they are abstract or overriding a method.",
          "IsOverride": "Gets whether this member is overriding another member.",
          "IsOverridable": "Gets if the member can be overridden. Returns true when the member is \u0022abstract\u0022, \u0022virtual\u0022 or \u0022override\u0022 but not \u0022sealed\u0022.",
          "Substitution": "Gets the substitution belonging to this specialized member.\r\nReturns TypeParameterSubstitution.Identity for not specialized members.",
          "GetAttributes": "Gets the attributes on this entity.\r\nDoes not include inherited attributes.",
          "Specialize": "Specializes this member with the given substitution.\r\nIf this member is already specialized, the new substitution is composed with the existing substition.",
          "Equals": "Gets whether the members are considered equal when applying the specified type normalization."
        }
      },
      "IField": {
        "Body": "class IField {\n    \u002Bstring Name*\n    \u002Bbool IsReadOnly*\n    \u002Bbool ReturnTypeIsRefReadOnly*\n    \u002Bbool IsVolatile*\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "IMember": [
            null
          ],
          "IEntity": [
            null
          ],
          "ISymbol": [
            null
          ],
          "ICompilationProvider": [
            null
          ],
          "INamedElement": [
            null
          ],
          "IVariable": [
            null
          ]
        },
        "Inherited": {
          "ISymbol": {
            "FlatMembers": "IField : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          },
          "ICompilationProvider": {
            "FlatMembers": "IField : \u002BICompilation Compilation*"
          },
          "INamedElement": {
            "FlatMembers": "IField : \u002Bstring FullName*\nIField : \u002Bstring Name*\nIField : \u002Bstring ReflectionName*\nIField : \u002Bstring Namespace*"
          },
          "IEntity": {
            "FlatMembers": "IField : \u002BEntityHandle MetadataToken*\nIField : \u002Bstring Name*\nIField : \u002BITypeDefinition DeclaringTypeDefinition*\nIField : \u002BIType DeclaringType*\nIField : \u002BIModule ParentModule*\nIField : \u002Bbool IsStatic*\nIField : \u002Bbool IsAbstract*\nIField : \u002Bbool IsSealed*\nIField : \u002BGetAttributes()* IEnumerable\u2770IAttribute\u2771\nIField : \u002BHasAttribute(KnownAttribute attribute)* bool\nIField : \u002BGetAttribute(KnownAttribute attribute)* IAttribute",
            "HasOne": {
              "Accessibility": "Accessibility"
            }
          },
          "IMember": {
            "FlatMembers": "IField : \u002BIMember MemberDefinition*\nIField : \u002BIType ReturnType*\nIField : \u002BIType DeclaringType*\nIField : \u002BIEnumerable\u2770IMember\u2771 ExplicitlyImplementedInterfaceMembers*\nIField : \u002Bbool IsExplicitInterfaceImplementation*\nIField : \u002Bbool IsVirtual*\nIField : \u002Bbool IsOverride*\nIField : \u002Bbool IsOverridable*\nIField : \u002BTypeParameterSubstitution Substitution*\nIField : \u002BSpecialize(TypeParameterSubstitution substitution)* IMember\nIField : \u002BEquals(IMember obj, TypeVisitor typeNormalization)* bool"
          },
          "IVariable": {
            "FlatMembers": "IField : \u002Bstring Name*\nIField : \u002BIType Type*\nIField : \u002Bbool IsConst*\nIField : \u002BGetConstantValue(bool throwOnInvalidMetadata)* object"
          }
        },
        "XmlDocs": {
          "": "Represents a field or constant.",
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Name": "Gets the name of the field.",
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null.",
          "FullName": "Gets the fully qualified name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Collections.Generic.List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment.SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "ReflectionName": "Gets the full reflection name of the element.\r\n\r\n[remarks]\r\nFor types, the reflection name can be parsed back into a ITypeReference by using\r\n[ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)].\r\n[/remarks]\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Int32[][,]\u0022 for C# int[,][][br /]\r\n\u0022System.Collections.Generic.List\u00601[[System.String]]\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment\u002BSpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Namespace": "Gets the full name of the namespace containing this entity.",
          "MetadataToken": "Gets the metadata token for this entity.\r\n\r\n[remarks]\r\nThe token is only valid within the context of the assembly defining this entity.\r\nToken may be 0 if this is a generated member.\r\nNote: specialized members will return the token of the member definition.\r\n[/remarks]",
          "DeclaringTypeDefinition": "Gets the declaring class.\r\nFor members, this is the class that contains the member.\r\nFor nested classes, this is the outer class. For top-level entities, this property returns null.",
          "DeclaringType": "Gets/Sets the declaring type (incl. type arguments, if any).\r\nIf this is not a specialized member, the value returned is equal to [ICSharpCode.Decompiler.TypeSystem.IEntity.DeclaringTypeDefinition].",
          "ParentModule": "The module in which this entity is defined.\r\nMay return null, if the IEntity was not created from a module.",
          "Accessibility": "Gets the accessibility of this entity.",
          "IsStatic": "Gets whether this entity is static.\r\nReturns true if either the \u0027static\u0027 or the \u0027const\u0027 modifier is set.",
          "IsAbstract": "Returns whether this entity is abstract.\r\n\r\n[remarks]Static classes also count as abstract classes.[/remarks]",
          "IsSealed": "Returns whether this entity is sealed.\r\n\r\n[remarks]Static classes also count as sealed classes.[/remarks]",
          "MemberDefinition": "Gets the original member definition for this member.\r\nReturns [c]this[/c] if this is not a specialized member.\r\nSpecialized members are the result of overload resolution with type substitution.",
          "ReturnType": "Gets the return type of this member.\r\nThis property never returns [c]null[/c].",
          "ExplicitlyImplementedInterfaceMembers": "Gets the interface members explicitly implemented by this member.\r\n\r\n[remarks]\r\nFor methods, equivalent to (\r\nfrom impl in DeclaringTypeDefinition.GetExplicitInterfaceImplementations()\r\nwhere impl.Implementation == this\r\nselect impl.InterfaceMethod\r\n),\r\nbut may be more efficient than searching the whole list.\r\n\r\nNote that it is possible for a class to implement an interface using members in a\r\nbase class unrelated to that interface:\r\nclass BaseClass { public void Dispose() {} }\r\nclass C : BaseClass, IDisposable { }\r\nIn this case, the interface member will not show up in (BaseClass.Dispose).ImplementedInterfaceMembers,\r\nso use (C).GetInterfaceImplementations() instead to handle this case.\r\n[/remarks]",
          "IsExplicitInterfaceImplementation": "Gets whether this member is explicitly implementing an interface.",
          "IsVirtual": "Gets if the member is virtual. Is true only if the \u0022virtual\u0022 modifier was used, but non-virtual\r\nmembers can be overridden, too; if they are abstract or overriding a method.",
          "IsOverride": "Gets whether this member is overriding another member.",
          "IsOverridable": "Gets if the member can be overridden. Returns true when the member is \u0022abstract\u0022, \u0022virtual\u0022 or \u0022override\u0022 but not \u0022sealed\u0022.",
          "Substitution": "Gets the substitution belonging to this specialized member.\r\nReturns TypeParameterSubstitution.Identity for not specialized members.",
          "Type": "Gets the type of the variable.",
          "IsConst": "Gets whether this variable is a constant (C#-like const).",
          "IsReadOnly": "Gets whether this field is readonly.",
          "ReturnTypeIsRefReadOnly": "Gets whether the field type is \u0027ref readonly\u0027.",
          "IsVolatile": "Gets whether this field is volatile.",
          "GetAttributes": "Gets the attributes on this entity.\r\nDoes not include inherited attributes.",
          "Specialize": "Specializes this member with the given substitution.\r\nIf this member is already specialized, the new substitution is composed with the existing substition.",
          "Equals": "Gets whether the members are considered equal when applying the specified type normalization.",
          "GetConstantValue": "If this field is a constant, retrieves the value.\r\nFor parameters, this is the default value."
        }
      },
      "IFreezable": {
        "Body": "class IFreezable {\n    \u002Bbool IsFrozen*\n    \u002BFreeze()* void\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "IsFrozen": "Gets if this instance is frozen. Frozen instances are immutable and thus thread-safe.",
          "Freeze": "Freezes this instance."
        }
      },
      "IMember": {
        "Body": "class IMember {\n    \u002BIMember MemberDefinition*\n    \u002BIType ReturnType*\n    \u002BIType DeclaringType*\n    \u002BIEnumerable\u2770IMember\u2771 ExplicitlyImplementedInterfaceMembers*\n    \u002Bbool IsExplicitInterfaceImplementation*\n    \u002Bbool IsVirtual*\n    \u002Bbool IsOverride*\n    \u002Bbool IsOverridable*\n    \u002BTypeParameterSubstitution Substitution*\n    \u002BSpecialize(TypeParameterSubstitution substitution)* IMember\n    \u002BEquals(IMember obj, TypeVisitor typeNormalization)* bool\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "IEntity": [
            null
          ],
          "ISymbol": [
            null
          ],
          "ICompilationProvider": [
            null
          ],
          "INamedElement": [
            null
          ]
        },
        "Inherited": {
          "ISymbol": {
            "FlatMembers": "IMember : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          },
          "ICompilationProvider": {
            "FlatMembers": "IMember : \u002BICompilation Compilation*"
          },
          "INamedElement": {
            "FlatMembers": "IMember : \u002Bstring FullName*\nIMember : \u002Bstring Name*\nIMember : \u002Bstring ReflectionName*\nIMember : \u002Bstring Namespace*"
          },
          "IEntity": {
            "FlatMembers": "IMember : \u002BEntityHandle MetadataToken*\nIMember : \u002Bstring Name*\nIMember : \u002BITypeDefinition DeclaringTypeDefinition*\nIMember : \u002BIType DeclaringType*\nIMember : \u002BIModule ParentModule*\nIMember : \u002Bbool IsStatic*\nIMember : \u002Bbool IsAbstract*\nIMember : \u002Bbool IsSealed*\nIMember : \u002BGetAttributes()* IEnumerable\u2770IAttribute\u2771\nIMember : \u002BHasAttribute(KnownAttribute attribute)* bool\nIMember : \u002BGetAttribute(KnownAttribute attribute)* IAttribute",
            "HasOne": {
              "Accessibility": "Accessibility"
            }
          }
        },
        "XmlDocs": {
          "": "Method/field/property/event.",
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Name": "Gets the short name of the entity.",
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null.",
          "FullName": "Gets the fully qualified name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Collections.Generic.List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment.SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "ReflectionName": "Gets the full reflection name of the element.\r\n\r\n[remarks]\r\nFor types, the reflection name can be parsed back into a ITypeReference by using\r\n[ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)].\r\n[/remarks]\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Int32[][,]\u0022 for C# int[,][][br /]\r\n\u0022System.Collections.Generic.List\u00601[[System.String]]\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment\u002BSpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Namespace": "Gets the full name of the namespace containing this entity.",
          "MetadataToken": "Gets the metadata token for this entity.\r\n\r\n[remarks]\r\nThe token is only valid within the context of the assembly defining this entity.\r\nToken may be 0 if this is a generated member.\r\nNote: specialized members will return the token of the member definition.\r\n[/remarks]",
          "DeclaringTypeDefinition": "Gets the declaring class.\r\nFor members, this is the class that contains the member.\r\nFor nested classes, this is the outer class. For top-level entities, this property returns null.",
          "DeclaringType": "Gets/Sets the declaring type (incl. type arguments, if any).\r\nIf this is not a specialized member, the value returned is equal to [ICSharpCode.Decompiler.TypeSystem.IEntity.DeclaringTypeDefinition].",
          "ParentModule": "The module in which this entity is defined.\r\nMay return null, if the IEntity was not created from a module.",
          "Accessibility": "Gets the accessibility of this entity.",
          "IsStatic": "Gets whether this entity is static.\r\nReturns true if either the \u0027static\u0027 or the \u0027const\u0027 modifier is set.",
          "IsAbstract": "Returns whether this entity is abstract.\r\n\r\n[remarks]Static classes also count as abstract classes.[/remarks]",
          "IsSealed": "Returns whether this entity is sealed.\r\n\r\n[remarks]Static classes also count as sealed classes.[/remarks]",
          "MemberDefinition": "Gets the original member definition for this member.\r\nReturns [c]this[/c] if this is not a specialized member.\r\nSpecialized members are the result of overload resolution with type substitution.",
          "ReturnType": "Gets the return type of this member.\r\nThis property never returns [c]null[/c].",
          "ExplicitlyImplementedInterfaceMembers": "Gets the interface members explicitly implemented by this member.\r\n\r\n[remarks]\r\nFor methods, equivalent to (\r\nfrom impl in DeclaringTypeDefinition.GetExplicitInterfaceImplementations()\r\nwhere impl.Implementation == this\r\nselect impl.InterfaceMethod\r\n),\r\nbut may be more efficient than searching the whole list.\r\n\r\nNote that it is possible for a class to implement an interface using members in a\r\nbase class unrelated to that interface:\r\nclass BaseClass { public void Dispose() {} }\r\nclass C : BaseClass, IDisposable { }\r\nIn this case, the interface member will not show up in (BaseClass.Dispose).ImplementedInterfaceMembers,\r\nso use (C).GetInterfaceImplementations() instead to handle this case.\r\n[/remarks]",
          "IsExplicitInterfaceImplementation": "Gets whether this member is explicitly implementing an interface.",
          "IsVirtual": "Gets if the member is virtual. Is true only if the \u0022virtual\u0022 modifier was used, but non-virtual\r\nmembers can be overridden, too; if they are abstract or overriding a method.",
          "IsOverride": "Gets whether this member is overriding another member.",
          "IsOverridable": "Gets if the member can be overridden. Returns true when the member is \u0022abstract\u0022, \u0022virtual\u0022 or \u0022override\u0022 but not \u0022sealed\u0022.",
          "Substitution": "Gets the substitution belonging to this specialized member.\r\nReturns TypeParameterSubstitution.Identity for not specialized members.",
          "GetAttributes": "Gets the attributes on this entity.\r\nDoes not include inherited attributes.",
          "Specialize": "Specializes this member with the given substitution.\r\nIf this member is already specialized, the new substitution is composed with the existing substition.",
          "Equals": "Gets whether the members are considered equal when applying the specified type normalization."
        }
      },
      "IMemberReference": {
        "Body": "class IMemberReference {\n    \u002BITypeReference DeclaringTypeReference*\n    \u002BResolve(ITypeResolveContext context)* IMember\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "DeclaringTypeReference": "Gets the declaring type reference for the member.",
          "Resolve": "Resolves the member.\r\n\r\n[param name=\u0022context\u0022]\r\nContext to use for resolving this member reference.\r\nWhich kind of context is required depends on the which kind of member reference this is;\r\nplease consult the documentation of the method that was used to create this member reference,\r\nor that of the class implementing this method.\r\n[/param]\r\n[returns]\r\nReturns the resolved member, or [c]null[/c] if the member could not be found.\r\n[/returns]"
        }
      },
      "IMethod": {
        "Body": "class IMethod {\n    \u002Bbool ReturnTypeIsRefReadOnly*\n    \u002Bbool IsInitOnly*\n    \u002Bbool ThisIsRefReadOnly*\n    \u002BIReadOnlyList\u2770ITypeParameter\u2771 TypeParameters*\n    \u002BIReadOnlyList\u2770IType\u2771 TypeArguments*\n    \u002Bbool IsExtensionMethod*\n    \u002Bbool IsLocalFunction*\n    \u002Bbool IsConstructor*\n    \u002Bbool IsDestructor*\n    \u002Bbool IsOperator*\n    \u002Bbool HasBody*\n    \u002Bbool IsAccessor*\n    \u002BIMember AccessorOwner*\n    \u002BMethodSemanticsAttributes AccessorKind*\n    \u002BIMethod ReducedFrom*\n    \u002BGetReturnTypeAttributes()* IEnumerable\u2770IAttribute\u2771\n    \u002BSpecialize(TypeParameterSubstitution substitution)* IMethod\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "IParameterizedMember": [
            null
          ],
          "IMember": [
            null
          ],
          "IEntity": [
            null
          ],
          "ISymbol": [
            null
          ],
          "ICompilationProvider": [
            null
          ],
          "INamedElement": [
            null
          ]
        },
        "Inherited": {
          "ISymbol": {
            "FlatMembers": "IMethod : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          },
          "ICompilationProvider": {
            "FlatMembers": "IMethod : \u002BICompilation Compilation*"
          },
          "INamedElement": {
            "FlatMembers": "IMethod : \u002Bstring FullName*\nIMethod : \u002Bstring Name*\nIMethod : \u002Bstring ReflectionName*\nIMethod : \u002Bstring Namespace*"
          },
          "IEntity": {
            "FlatMembers": "IMethod : \u002BEntityHandle MetadataToken*\nIMethod : \u002Bstring Name*\nIMethod : \u002BITypeDefinition DeclaringTypeDefinition*\nIMethod : \u002BIType DeclaringType*\nIMethod : \u002BIModule ParentModule*\nIMethod : \u002Bbool IsStatic*\nIMethod : \u002Bbool IsAbstract*\nIMethod : \u002Bbool IsSealed*\nIMethod : \u002BGetAttributes()* IEnumerable\u2770IAttribute\u2771\nIMethod : \u002BHasAttribute(KnownAttribute attribute)* bool\nIMethod : \u002BGetAttribute(KnownAttribute attribute)* IAttribute",
            "HasOne": {
              "Accessibility": "Accessibility"
            }
          },
          "IMember": {
            "FlatMembers": "IMethod : \u002BIMember MemberDefinition*\nIMethod : \u002BIType ReturnType*\nIMethod : \u002BIType DeclaringType*\nIMethod : \u002BIEnumerable\u2770IMember\u2771 ExplicitlyImplementedInterfaceMembers*\nIMethod : \u002Bbool IsExplicitInterfaceImplementation*\nIMethod : \u002Bbool IsVirtual*\nIMethod : \u002Bbool IsOverride*\nIMethod : \u002Bbool IsOverridable*\nIMethod : \u002BTypeParameterSubstitution Substitution*\nIMethod : \u002BSpecialize(TypeParameterSubstitution substitution)* IMember\nIMethod : \u002BEquals(IMember obj, TypeVisitor typeNormalization)* bool"
          },
          "IParameterizedMember": {
            "FlatMembers": "IMethod : \u002BIReadOnlyList\u2770IParameter\u2771 Parameters*"
          }
        },
        "XmlDocs": {
          "": "Represents a method, constructor, destructor or operator.",
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Name": "Gets the short name of the entity.",
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null.",
          "FullName": "Gets the fully qualified name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Collections.Generic.List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment.SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "ReflectionName": "Gets the full reflection name of the element.\r\n\r\n[remarks]\r\nFor types, the reflection name can be parsed back into a ITypeReference by using\r\n[ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)].\r\n[/remarks]\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Int32[][,]\u0022 for C# int[,][][br /]\r\n\u0022System.Collections.Generic.List\u00601[[System.String]]\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment\u002BSpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Namespace": "Gets the full name of the namespace containing this entity.",
          "MetadataToken": "Gets the metadata token for this entity.\r\n\r\n[remarks]\r\nThe token is only valid within the context of the assembly defining this entity.\r\nToken may be 0 if this is a generated member.\r\nNote: specialized members will return the token of the member definition.\r\n[/remarks]",
          "DeclaringTypeDefinition": "Gets the declaring class.\r\nFor members, this is the class that contains the member.\r\nFor nested classes, this is the outer class. For top-level entities, this property returns null.",
          "DeclaringType": "Gets/Sets the declaring type (incl. type arguments, if any).\r\nIf this is not a specialized member, the value returned is equal to [ICSharpCode.Decompiler.TypeSystem.IEntity.DeclaringTypeDefinition].",
          "ParentModule": "The module in which this entity is defined.\r\nMay return null, if the IEntity was not created from a module.",
          "Accessibility": "Gets the accessibility of this entity.",
          "IsStatic": "Gets whether this entity is static.\r\nReturns true if either the \u0027static\u0027 or the \u0027const\u0027 modifier is set.",
          "IsAbstract": "Returns whether this entity is abstract.\r\n\r\n[remarks]Static classes also count as abstract classes.[/remarks]",
          "IsSealed": "Returns whether this entity is sealed.\r\n\r\n[remarks]Static classes also count as sealed classes.[/remarks]",
          "MemberDefinition": "Gets the original member definition for this member.\r\nReturns [c]this[/c] if this is not a specialized member.\r\nSpecialized members are the result of overload resolution with type substitution.",
          "ReturnType": "Gets the return type of this member.\r\nThis property never returns [c]null[/c].",
          "ExplicitlyImplementedInterfaceMembers": "Gets the interface members explicitly implemented by this member.\r\n\r\n[remarks]\r\nFor methods, equivalent to (\r\nfrom impl in DeclaringTypeDefinition.GetExplicitInterfaceImplementations()\r\nwhere impl.Implementation == this\r\nselect impl.InterfaceMethod\r\n),\r\nbut may be more efficient than searching the whole list.\r\n\r\nNote that it is possible for a class to implement an interface using members in a\r\nbase class unrelated to that interface:\r\nclass BaseClass { public void Dispose() {} }\r\nclass C : BaseClass, IDisposable { }\r\nIn this case, the interface member will not show up in (BaseClass.Dispose).ImplementedInterfaceMembers,\r\nso use (C).GetInterfaceImplementations() instead to handle this case.\r\n[/remarks]",
          "IsExplicitInterfaceImplementation": "Gets whether this member is explicitly implementing an interface.",
          "IsVirtual": "Gets if the member is virtual. Is true only if the \u0022virtual\u0022 modifier was used, but non-virtual\r\nmembers can be overridden, too; if they are abstract or overriding a method.",
          "IsOverride": "Gets whether this member is overriding another member.",
          "IsOverridable": "Gets if the member can be overridden. Returns true when the member is \u0022abstract\u0022, \u0022virtual\u0022 or \u0022override\u0022 but not \u0022sealed\u0022.",
          "Substitution": "Gets the substitution belonging to this specialized member.\r\nReturns TypeParameterSubstitution.Identity for not specialized members.",
          "ReturnTypeIsRefReadOnly": "Gets whether the return type is \u0027ref readonly\u0027.",
          "IsInitOnly": "Gets whether this method may only be called on fresh instances.\r\nUsed with C# 9 \u0060init;\u0060 property setters.",
          "ThisIsRefReadOnly": "Gets whether the method accepts the \u0027this\u0027 reference as ref readonly.\r\nThis can be either because the method is C# 8.0 \u0027readonly\u0027, or because it is within a C# 7.2 \u0027readonly struct\u0027",
          "TypeParameters": "Gets the type parameters of this method; or an empty list if the method is not generic.",
          "TypeArguments": "Gets the type arguments passed to this method.\r\nIf the method is generic but not parameterized yet, this property returns the type parameters,\r\nas if the method was parameterized with its own type arguments ([c]void M\u0026lt;T\u0026gt;() { M\u0026lt;T\u0026gt;(); }[/c]).",
          "HasBody": "Gets whether the method has a body.\r\nThis property returns [c]false[/c] for [c]abstract[/c] or [c]extern[/c] methods,\r\nor for [c]partial[/c] methods without implementation.",
          "IsAccessor": "Gets whether the method is a property/event accessor.",
          "AccessorOwner": "If this method is an accessor, returns the corresponding property/event.\r\nOtherwise, returns null.",
          "AccessorKind": "Gets the kind of accessor this is.",
          "ReducedFrom": "If this method is reduced from an extension method or a local function returns the original method, [c]null[/c] otherwise.\r\nA reduced method doesn\u0027t contain the extension method parameter. That means that it has one parameter less than its definition.\r\nA local function doesn\u0027t contain compiler-generated method parameters at the end.",
          "GetAttributes": "Gets the attributes on this entity.\r\nDoes not include inherited attributes.",
          "Specialize": "Specializes this method with the given substitution.\r\nIf this method is already specialized, the new substitution is composed with the existing substition.",
          "Equals": "Gets whether the members are considered equal when applying the specified type normalization.",
          "GetReturnTypeAttributes": "Gets the attributes associated with the return type. (e.g. [return: MarshalAs(...)])\r\n\r\n[remarks]\r\nDoes not include inherited attributes.\r\n[/remarks]"
        }
      },
      "IModule": {
        "Body": "class IModule {\n    \u002BMetadataFile MetadataFile*\n    \u002Bbool IsMainModule*\n    \u002Bstring AssemblyName*\n    \u002BVersion AssemblyVersion*\n    \u002Bstring FullAssemblyName*\n    \u002BINamespace RootNamespace*\n    \u002BIEnumerable\u2770ITypeDefinition\u2771 TopLevelTypeDefinitions*\n    \u002BIEnumerable\u2770ITypeDefinition\u2771 TypeDefinitions*\n    \u002BGetAssemblyAttributes()* IEnumerable\u2770IAttribute\u2771\n    \u002BGetModuleAttributes()* IEnumerable\u2770IAttribute\u2771\n    \u002BInternalsVisibleTo(IModule module)* bool\n    \u002BGetTypeDefinition(TopLevelTypeName topLevelTypeName)* ITypeDefinition\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "ISymbol": [
            null
          ],
          "ICompilationProvider": [
            null
          ]
        },
        "Inherited": {
          "ISymbol": {
            "FlatMembers": "IModule : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          },
          "ICompilationProvider": {
            "FlatMembers": "IModule : \u002BICompilation Compilation*"
          }
        },
        "XmlDocs": {
          "": "Represents a metadata module.",
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Name": "Gets the short name of the symbol.",
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null.",
          "MetadataFile": "Gets the underlying metadata file. May return null, if the module was not created from a file.",
          "IsMainModule": "Gets whether this assembly is the main assembly of the compilation.",
          "AssemblyName": "Gets the assembly name (short name).",
          "AssemblyVersion": "Gets the assembly version.",
          "FullAssemblyName": "Gets the full assembly name (including public key token etc.)",
          "RootNamespace": "Gets the root namespace for this module.\r\n\r\n[remarks]\r\nThis always is the namespace without a name - it\u0027s unrelated to the \u0027root namespace\u0027 project setting.\r\nIt contains only subnamespaces and types defined in this module -- use ICompilation.RootNamespace\r\nto get the combined view of all referenced assemblies.\r\n[/remarks]",
          "TopLevelTypeDefinitions": "Gets all non-nested types in the assembly.",
          "TypeDefinitions": "Gets all types in the assembly, including nested types.",
          "GetAssemblyAttributes": "Gets all assembly attributes.",
          "GetModuleAttributes": "Gets all module attributes.",
          "InternalsVisibleTo": "Gets whether the internals of this assembly are visible in the specified assembly.",
          "GetTypeDefinition": "Gets the type definition for a top-level type.\r\n\r\n[remarks]This method uses ordinal name comparison, not the compilation\u0027s name comparer.[/remarks]"
        }
      },
      "IModuleReference": {
        "Body": "class IModuleReference {\n    \u002BResolve(ITypeResolveContext context)* IModule\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Interface used to help with construction of the type system.\r\n\r\n[remarks]\r\nThe type system is an immutable cyclic data structure:\r\nthe compilation (ICompilation) has references to all modules,\r\nand each module has a reference back to the compilation.\r\n\r\nModule references are used to solve this cyclic dependency:\r\nThe compilation constructor accepts module references,\r\nand only the IModuleReference.Resolve() function can observe a\r\npartially-constructed compilation; but not any user code.\r\n[/remarks]",
          "Resolve": "Resolves this metadata module."
        }
      },
      "INamedElement": {
        "Body": "class INamedElement {\n    \u002Bstring FullName*\n    \u002Bstring Name*\n    \u002Bstring ReflectionName*\n    \u002Bstring Namespace*\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "FullName": "Gets the fully qualified name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Collections.Generic.List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment.SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Name": "Gets the short name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022Int32[]\u0022 for int[][br /]\r\n\u0022List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "ReflectionName": "Gets the full reflection name of the element.\r\n\r\n[remarks]\r\nFor types, the reflection name can be parsed back into a ITypeReference by using\r\n[ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)].\r\n[/remarks]\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Int32[][,]\u0022 for C# int[,][][br /]\r\n\u0022System.Collections.Generic.List\u00601[[System.String]]\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment\u002BSpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Namespace": "Gets the full name of the namespace containing this entity."
        }
      },
      "INamespace": {
        "Body": "class INamespace {\n    \u002Bstring ExternAlias*\n    \u002Bstring FullName*\n    \u002Bstring Name*\n    \u002BINamespace ParentNamespace*\n    \u002BIEnumerable\u2770INamespace\u2771 ChildNamespaces*\n    \u002BIEnumerable\u2770ITypeDefinition\u2771 Types*\n    \u002BIEnumerable\u2770IModule\u2771 ContributingModules*\n    \u002BGetChildNamespace(string name)* INamespace\n    \u002BGetTypeDefinition(string name, int typeParameterCount)* ITypeDefinition\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "ISymbol": [
            null
          ],
          "ICompilationProvider": [
            null
          ]
        },
        "Inherited": {
          "ISymbol": {
            "FlatMembers": "INamespace : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          },
          "ICompilationProvider": {
            "FlatMembers": "INamespace : \u002BICompilation Compilation*"
          }
        },
        "XmlDocs": {
          "": "Represents a resolved namespace.",
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Name": "Gets the short name of this namespace (e.g. \u0022Collections\u0022).",
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null.",
          "ExternAlias": "Gets the extern alias for this namespace.\r\nReturns an empty string for normal namespaces.",
          "FullName": "Gets the full name of this namespace. (e.g. \u0022System.Collections\u0022)",
          "ParentNamespace": "Gets the parent namespace.\r\nReturns null if this is the root namespace.",
          "ChildNamespaces": "Gets the child namespaces in this namespace.",
          "Types": "Gets the types in this namespace.",
          "ContributingModules": "Gets the modules that contribute types to this namespace (or to child namespaces).",
          "GetChildNamespace": "Gets a direct child namespace by its short name.\r\nReturns null when the namespace cannot be found.\r\n\r\n[remarks]\r\nThis method uses the compilation\u0027s current string comparer.\r\n[/remarks]",
          "GetTypeDefinition": "Gets the type with the specified short name and type parameter count.\r\nReturns null if the type cannot be found.\r\n\r\n[remarks]\r\nThis method uses the compilation\u0027s current string comparer.\r\n[/remarks]"
        }
      },
      "IParameter": {
        "Body": "class IParameter {\n    \u002Bbool IsParams*\n    \u002Bbool IsOptional*\n    \u002Bbool HasConstantValueInSignature*\n    \u002BIParameterizedMember Owner*\n    \u002BGetAttributes()* IEnumerable\u2770IAttribute\u2771\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "IVariable": [
            null
          ],
          "ISymbol": [
            null
          ]
        },
        "Inherited": {
          "ISymbol": {
            "FlatMembers": "IParameter : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          },
          "IVariable": {
            "FlatMembers": "IParameter : \u002Bstring Name*\nIParameter : \u002BIType Type*\nIParameter : \u002Bbool IsConst*\nIParameter : \u002BGetConstantValue(bool throwOnInvalidMetadata)* object"
          }
        },
        "XmlDocs": {
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Name": "Gets the name of the variable.",
          "Type": "Gets the type of the variable.",
          "IsConst": "Gets whether this variable is a constant (C#-like const).",
          "ReferenceKind": "Gets the reference kind of this parameter.",
          "Lifetime": "C# 11 scoped annotation.",
          "IsParams": "Gets whether this parameter is a C# \u0027params\u0027 parameter.",
          "IsOptional": "Gets whether this parameter is optional.\r\nThe default value is given by the [ICSharpCode.Decompiler.TypeSystem.IVariable.GetConstantValue(System.Boolean)] function.",
          "HasConstantValueInSignature": "Gets whether this parameter has a constant value when presented in method signature.\r\n\r\n[remarks]\r\nThis can only be [c]true[/c] if the parameter is optional, and it\u0027s true for most \r\noptional parameters. However it is possible to compile a parameter without a default value,\r\nand some parameters handle their default values in an special way.\r\n\r\nFor example, [System.Runtime.CompilerServices.DecimalConstantAttribute] does not use normal constants,\r\nso when [ICSharpCode.Decompiler.DecompilerSettings.DecimalConstants] is [c]false[/c]\r\nwe expose [c]DecimalConstantAttribute[/c] directly instead of a constant value.\r\n\r\nOn the call sites, though, we can still use the value inferred from the attribute.\r\n[/remarks]",
          "Owner": "Gets the owner of this parameter.\r\nMay return null; for example when parameters belong to lambdas or anonymous methods.",
          "GetConstantValue": "If this field is a constant, retrieves the value.\r\nFor parameters, this is the default value.",
          "GetAttributes": "Gets the attributes on this parameter."
        },
        "HasOne": {
          "ReferenceKind": "ReferenceKind",
          "Lifetime": "LifetimeAnnotation"
        }
      },
      "IParameterizedMember": {
        "Body": "class IParameterizedMember {\n    \u002BIReadOnlyList\u2770IParameter\u2771 Parameters*\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "IMember": [
            null
          ],
          "IEntity": [
            null
          ],
          "ISymbol": [
            null
          ],
          "ICompilationProvider": [
            null
          ],
          "INamedElement": [
            null
          ]
        },
        "Inherited": {
          "ISymbol": {
            "FlatMembers": "IParameterizedMember : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          },
          "ICompilationProvider": {
            "FlatMembers": "IParameterizedMember : \u002BICompilation Compilation*"
          },
          "INamedElement": {
            "FlatMembers": "IParameterizedMember : \u002Bstring FullName*\nIParameterizedMember : \u002Bstring Name*\nIParameterizedMember : \u002Bstring ReflectionName*\nIParameterizedMember : \u002Bstring Namespace*"
          },
          "IEntity": {
            "FlatMembers": "IParameterizedMember : \u002BEntityHandle MetadataToken*\nIParameterizedMember : \u002Bstring Name*\nIParameterizedMember : \u002BITypeDefinition DeclaringTypeDefinition*\nIParameterizedMember : \u002BIType DeclaringType*\nIParameterizedMember : \u002BIModule ParentModule*\nIParameterizedMember : \u002Bbool IsStatic*\nIParameterizedMember : \u002Bbool IsAbstract*\nIParameterizedMember : \u002Bbool IsSealed*\nIParameterizedMember : \u002BGetAttributes()* IEnumerable\u2770IAttribute\u2771\nIParameterizedMember : \u002BHasAttribute(KnownAttribute attribute)* bool\nIParameterizedMember : \u002BGetAttribute(KnownAttribute attribute)* IAttribute",
            "HasOne": {
              "Accessibility": "Accessibility"
            }
          },
          "IMember": {
            "FlatMembers": "IParameterizedMember : \u002BIMember MemberDefinition*\nIParameterizedMember : \u002BIType ReturnType*\nIParameterizedMember : \u002BIType DeclaringType*\nIParameterizedMember : \u002BIEnumerable\u2770IMember\u2771 ExplicitlyImplementedInterfaceMembers*\nIParameterizedMember : \u002Bbool IsExplicitInterfaceImplementation*\nIParameterizedMember : \u002Bbool IsVirtual*\nIParameterizedMember : \u002Bbool IsOverride*\nIParameterizedMember : \u002Bbool IsOverridable*\nIParameterizedMember : \u002BTypeParameterSubstitution Substitution*\nIParameterizedMember : \u002BSpecialize(TypeParameterSubstitution substitution)* IMember\nIParameterizedMember : \u002BEquals(IMember obj, TypeVisitor typeNormalization)* bool"
          }
        },
        "XmlDocs": {
          "": "Represents a method or property.",
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Name": "Gets the short name of the entity.",
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null.",
          "FullName": "Gets the fully qualified name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Collections.Generic.List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment.SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "ReflectionName": "Gets the full reflection name of the element.\r\n\r\n[remarks]\r\nFor types, the reflection name can be parsed back into a ITypeReference by using\r\n[ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)].\r\n[/remarks]\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Int32[][,]\u0022 for C# int[,][][br /]\r\n\u0022System.Collections.Generic.List\u00601[[System.String]]\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment\u002BSpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Namespace": "Gets the full name of the namespace containing this entity.",
          "MetadataToken": "Gets the metadata token for this entity.\r\n\r\n[remarks]\r\nThe token is only valid within the context of the assembly defining this entity.\r\nToken may be 0 if this is a generated member.\r\nNote: specialized members will return the token of the member definition.\r\n[/remarks]",
          "DeclaringTypeDefinition": "Gets the declaring class.\r\nFor members, this is the class that contains the member.\r\nFor nested classes, this is the outer class. For top-level entities, this property returns null.",
          "DeclaringType": "Gets/Sets the declaring type (incl. type arguments, if any).\r\nIf this is not a specialized member, the value returned is equal to [ICSharpCode.Decompiler.TypeSystem.IEntity.DeclaringTypeDefinition].",
          "ParentModule": "The module in which this entity is defined.\r\nMay return null, if the IEntity was not created from a module.",
          "Accessibility": "Gets the accessibility of this entity.",
          "IsStatic": "Gets whether this entity is static.\r\nReturns true if either the \u0027static\u0027 or the \u0027const\u0027 modifier is set.",
          "IsAbstract": "Returns whether this entity is abstract.\r\n\r\n[remarks]Static classes also count as abstract classes.[/remarks]",
          "IsSealed": "Returns whether this entity is sealed.\r\n\r\n[remarks]Static classes also count as sealed classes.[/remarks]",
          "MemberDefinition": "Gets the original member definition for this member.\r\nReturns [c]this[/c] if this is not a specialized member.\r\nSpecialized members are the result of overload resolution with type substitution.",
          "ReturnType": "Gets the return type of this member.\r\nThis property never returns [c]null[/c].",
          "ExplicitlyImplementedInterfaceMembers": "Gets the interface members explicitly implemented by this member.\r\n\r\n[remarks]\r\nFor methods, equivalent to (\r\nfrom impl in DeclaringTypeDefinition.GetExplicitInterfaceImplementations()\r\nwhere impl.Implementation == this\r\nselect impl.InterfaceMethod\r\n),\r\nbut may be more efficient than searching the whole list.\r\n\r\nNote that it is possible for a class to implement an interface using members in a\r\nbase class unrelated to that interface:\r\nclass BaseClass { public void Dispose() {} }\r\nclass C : BaseClass, IDisposable { }\r\nIn this case, the interface member will not show up in (BaseClass.Dispose).ImplementedInterfaceMembers,\r\nso use (C).GetInterfaceImplementations() instead to handle this case.\r\n[/remarks]",
          "IsExplicitInterfaceImplementation": "Gets whether this member is explicitly implementing an interface.",
          "IsVirtual": "Gets if the member is virtual. Is true only if the \u0022virtual\u0022 modifier was used, but non-virtual\r\nmembers can be overridden, too; if they are abstract or overriding a method.",
          "IsOverride": "Gets whether this member is overriding another member.",
          "IsOverridable": "Gets if the member can be overridden. Returns true when the member is \u0022abstract\u0022, \u0022virtual\u0022 or \u0022override\u0022 but not \u0022sealed\u0022.",
          "Substitution": "Gets the substitution belonging to this specialized member.\r\nReturns TypeParameterSubstitution.Identity for not specialized members.",
          "GetAttributes": "Gets the attributes on this entity.\r\nDoes not include inherited attributes.",
          "Specialize": "Specializes this member with the given substitution.\r\nIf this member is already specialized, the new substitution is composed with the existing substition.",
          "Equals": "Gets whether the members are considered equal when applying the specified type normalization."
        }
      },
      "IProperty": {
        "Body": "class IProperty {\n    \u002Bbool CanGet*\n    \u002Bbool CanSet*\n    \u002BIMethod Getter*\n    \u002BIMethod Setter*\n    \u002Bbool IsIndexer*\n    \u002Bbool ReturnTypeIsRefReadOnly*\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "IParameterizedMember": [
            null
          ],
          "IMember": [
            null
          ],
          "IEntity": [
            null
          ],
          "ISymbol": [
            null
          ],
          "ICompilationProvider": [
            null
          ],
          "INamedElement": [
            null
          ]
        },
        "Inherited": {
          "ISymbol": {
            "FlatMembers": "IProperty : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          },
          "ICompilationProvider": {
            "FlatMembers": "IProperty : \u002BICompilation Compilation*"
          },
          "INamedElement": {
            "FlatMembers": "IProperty : \u002Bstring FullName*\nIProperty : \u002Bstring Name*\nIProperty : \u002Bstring ReflectionName*\nIProperty : \u002Bstring Namespace*"
          },
          "IEntity": {
            "FlatMembers": "IProperty : \u002BEntityHandle MetadataToken*\nIProperty : \u002Bstring Name*\nIProperty : \u002BITypeDefinition DeclaringTypeDefinition*\nIProperty : \u002BIType DeclaringType*\nIProperty : \u002BIModule ParentModule*\nIProperty : \u002Bbool IsStatic*\nIProperty : \u002Bbool IsAbstract*\nIProperty : \u002Bbool IsSealed*\nIProperty : \u002BGetAttributes()* IEnumerable\u2770IAttribute\u2771\nIProperty : \u002BHasAttribute(KnownAttribute attribute)* bool\nIProperty : \u002BGetAttribute(KnownAttribute attribute)* IAttribute",
            "HasOne": {
              "Accessibility": "Accessibility"
            }
          },
          "IMember": {
            "FlatMembers": "IProperty : \u002BIMember MemberDefinition*\nIProperty : \u002BIType ReturnType*\nIProperty : \u002BIType DeclaringType*\nIProperty : \u002BIEnumerable\u2770IMember\u2771 ExplicitlyImplementedInterfaceMembers*\nIProperty : \u002Bbool IsExplicitInterfaceImplementation*\nIProperty : \u002Bbool IsVirtual*\nIProperty : \u002Bbool IsOverride*\nIProperty : \u002Bbool IsOverridable*\nIProperty : \u002BTypeParameterSubstitution Substitution*\nIProperty : \u002BSpecialize(TypeParameterSubstitution substitution)* IMember\nIProperty : \u002BEquals(IMember obj, TypeVisitor typeNormalization)* bool"
          },
          "IParameterizedMember": {
            "FlatMembers": "IProperty : \u002BIReadOnlyList\u2770IParameter\u2771 Parameters*"
          }
        },
        "XmlDocs": {
          "": "Represents a property or indexer.",
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Name": "Gets the short name of the entity.",
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null.",
          "FullName": "Gets the fully qualified name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Collections.Generic.List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment.SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "ReflectionName": "Gets the full reflection name of the element.\r\n\r\n[remarks]\r\nFor types, the reflection name can be parsed back into a ITypeReference by using\r\n[ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)].\r\n[/remarks]\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Int32[][,]\u0022 for C# int[,][][br /]\r\n\u0022System.Collections.Generic.List\u00601[[System.String]]\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment\u002BSpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Namespace": "Gets the full name of the namespace containing this entity.",
          "MetadataToken": "Gets the metadata token for this entity.\r\n\r\n[remarks]\r\nThe token is only valid within the context of the assembly defining this entity.\r\nToken may be 0 if this is a generated member.\r\nNote: specialized members will return the token of the member definition.\r\n[/remarks]",
          "DeclaringTypeDefinition": "Gets the declaring class.\r\nFor members, this is the class that contains the member.\r\nFor nested classes, this is the outer class. For top-level entities, this property returns null.",
          "DeclaringType": "Gets/Sets the declaring type (incl. type arguments, if any).\r\nIf this is not a specialized member, the value returned is equal to [ICSharpCode.Decompiler.TypeSystem.IEntity.DeclaringTypeDefinition].",
          "ParentModule": "The module in which this entity is defined.\r\nMay return null, if the IEntity was not created from a module.",
          "Accessibility": "Gets the accessibility of this entity.",
          "IsStatic": "Gets whether this entity is static.\r\nReturns true if either the \u0027static\u0027 or the \u0027const\u0027 modifier is set.",
          "IsAbstract": "Returns whether this entity is abstract.\r\n\r\n[remarks]Static classes also count as abstract classes.[/remarks]",
          "IsSealed": "Returns whether this entity is sealed.\r\n\r\n[remarks]Static classes also count as sealed classes.[/remarks]",
          "MemberDefinition": "Gets the original member definition for this member.\r\nReturns [c]this[/c] if this is not a specialized member.\r\nSpecialized members are the result of overload resolution with type substitution.",
          "ReturnType": "Gets the return type of this member.\r\nThis property never returns [c]null[/c].",
          "ExplicitlyImplementedInterfaceMembers": "Gets the interface members explicitly implemented by this member.\r\n\r\n[remarks]\r\nFor methods, equivalent to (\r\nfrom impl in DeclaringTypeDefinition.GetExplicitInterfaceImplementations()\r\nwhere impl.Implementation == this\r\nselect impl.InterfaceMethod\r\n),\r\nbut may be more efficient than searching the whole list.\r\n\r\nNote that it is possible for a class to implement an interface using members in a\r\nbase class unrelated to that interface:\r\nclass BaseClass { public void Dispose() {} }\r\nclass C : BaseClass, IDisposable { }\r\nIn this case, the interface member will not show up in (BaseClass.Dispose).ImplementedInterfaceMembers,\r\nso use (C).GetInterfaceImplementations() instead to handle this case.\r\n[/remarks]",
          "IsExplicitInterfaceImplementation": "Gets whether this member is explicitly implementing an interface.",
          "IsVirtual": "Gets if the member is virtual. Is true only if the \u0022virtual\u0022 modifier was used, but non-virtual\r\nmembers can be overridden, too; if they are abstract or overriding a method.",
          "IsOverride": "Gets whether this member is overriding another member.",
          "IsOverridable": "Gets if the member can be overridden. Returns true when the member is \u0022abstract\u0022, \u0022virtual\u0022 or \u0022override\u0022 but not \u0022sealed\u0022.",
          "Substitution": "Gets the substitution belonging to this specialized member.\r\nReturns TypeParameterSubstitution.Identity for not specialized members.",
          "ReturnTypeIsRefReadOnly": "Gets whether the return type is \u0027ref readonly\u0027.",
          "GetAttributes": "Gets the attributes on this entity.\r\nDoes not include inherited attributes.",
          "Specialize": "Specializes this member with the given substitution.\r\nIf this member is already specialized, the new substitution is composed with the existing substition.",
          "Equals": "Gets whether the members are considered equal when applying the specified type normalization."
        }
      },
      "ISupportsInterning": {
        "Body": "class ISupportsInterning {\n    \u002BGetHashCodeForInterning()* int\n    \u002BEqualsForInterning(ISupportsInterning other)* bool\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Interface for TypeSystem objects that support interning.\r\nSee [ICSharpCode.Decompiler.TypeSystem.InterningProvider] for more information.",
          "GetHashCodeForInterning": "Gets a hash code for interning.",
          "EqualsForInterning": "Equality test for interning."
        }
      },
      "ISymbol": {
        "Body": "class ISymbol {\n    \u002Bstring Name*\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Interface for type system symbols.",
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Name": "Gets the short name of the symbol."
        },
        "HasOne": {
          "SymbolKind": "SymbolKind"
        }
      },
      "IType": {
        "Body": "class IType {\n    \u002Bbool? IsReferenceType*\n    \u002Bbool IsByRefLike*\n    \u002BIType DeclaringType*\n    \u002Bint TypeParameterCount*\n    \u002BIReadOnlyList\u2770ITypeParameter\u2771 TypeParameters*\n    \u002BIReadOnlyList\u2770IType\u2771 TypeArguments*\n    \u002BIEnumerable\u2770IType\u2771 DirectBaseTypes*\n    \u002BChangeNullability(Nullability newNullability)* IType\n    \u002BGetDefinition()* ITypeDefinition\n    \u002BGetDefinitionOrUnknown()* ITypeDefinitionOrUnknown\n    \u002BAcceptVisitor(TypeVisitor visitor)* IType\n    \u002BVisitChildren(TypeVisitor visitor)* IType\n    \u002BGetSubstitution()* TypeParameterSubstitution\n    \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IType\u2771\n    \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IType\u2771\n    \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\n    \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\n    \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\n    \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IProperty\u2771\n    \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IField\u2771\n    \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IEvent\u2771\n    \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMember\u2771\n    \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "INamedElement": [
            null
          ],
          "System_IEquatable_T": [
            "IEquatable\u2770IType\u2771"
          ]
        },
        "Inherited": {
          "INamedElement": {
            "FlatMembers": "IType : \u002Bstring FullName*\nIType : \u002Bstring Name*\nIType : \u002Bstring ReflectionName*\nIType : \u002Bstring Namespace*"
          },
          "System_IEquatable_T": {
            "FlatMembers": "IType : \u002BEquals(IType other)* bool"
          }
        },
        "XmlDocs": {
          "": "This interface represents a resolved type in the type system.\r\n\r\n[remarks]\r\n\n\r\nA type is potentially\r\n- a type definition ([ICSharpCode.Decompiler.TypeSystem.ITypeDefinition], i.e. a class, struct, interface, delegate, or built-in primitive type)\r\n- a parameterized type ([ICSharpCode.Decompiler.TypeSystem.ParameterizedType], e.g. List\u0026lt;int\u0026gt;)\r\n- a type parameter ([ICSharpCode.Decompiler.TypeSystem.ITypeParameter], e.g. T)\r\n- an array ([ICSharpCode.Decompiler.TypeSystem.ArrayType])\r\n- a pointer ([ICSharpCode.Decompiler.TypeSystem.PointerType])\r\n- a managed reference ([ICSharpCode.Decompiler.TypeSystem.ByReferenceType])\r\n- one of the special types ([ICSharpCode.Decompiler.TypeSystem.SpecialType.UnknownType], [ICSharpCode.Decompiler.TypeSystem.SpecialType.NullType],\r\n[ICSharpCode.Decompiler.TypeSystem.SpecialType.Dynamic], [ICSharpCode.Decompiler.TypeSystem.SpecialType.UnboundTypeArgument])\r\n\r\nThe [ICSharpCode.Decompiler.TypeSystem.IType.Kind] property can be used to switch on the kind of a type.\r\n\n\r\n\n\r\nIType uses the null object pattern: [ICSharpCode.Decompiler.TypeSystem.SpecialType.UnknownType] serves as the null object.\r\nMethods or properties returning IType never return null unless documented otherwise.\r\n\n\r\n\n\r\nTypes should be compared for equality using the [System.IEquatable\u00601.Equals(\u00600)] method.\r\nIdentical types do not necessarily use the same object reference.\r\n\n\r\n[/remarks]",
          "FullName": "Gets the fully qualified name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Collections.Generic.List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment.SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Name": "Gets the short name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022Int32[]\u0022 for int[][br /]\r\n\u0022List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "ReflectionName": "Gets the full reflection name of the element.\r\n\r\n[remarks]\r\nFor types, the reflection name can be parsed back into a ITypeReference by using\r\n[ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)].\r\n[/remarks]\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Int32[][,]\u0022 for C# int[,][][br /]\r\n\u0022System.Collections.Generic.List\u00601[[System.String]]\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment\u002BSpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Namespace": "Gets the full name of the namespace containing this entity.",
          "Kind": "Gets the type kind.",
          "IsReferenceType": "Gets whether the type is a reference type or value type.\r\n\r\n[returns]\r\ntrue, if the type is a reference type.\r\nfalse, if the type is a value type.\r\nnull, if the type is not known (e.g. unconstrained generic type parameter or type not found)\r\n[/returns]",
          "IsByRefLike": "Gets whether this type is \u0022ref-like\u0022: a ByReferenceType or \u0022ref struct\u0022.",
          "Nullability": "Gets the nullability annotation on this type.",
          "DeclaringType": "Gets the parent type, if this is a nested type.\r\nReturns null for top-level types.",
          "TypeParameterCount": "Gets the number of type parameters.",
          "TypeParameters": "Gets the type parameters.\r\nReturns an empty list if this type is not generic.",
          "TypeArguments": "Gets the type arguments passed to this type.\r\nIf this type is a generic type definition that is not parameterized, this property returns the type parameters,\r\nas if the type was parameterized with its own type arguments ([c]class C\u0026lt;T\u0026gt; { C\u0026lt;T\u0026gt; field; }[/c]).",
          "DirectBaseTypes": "Gets the direct base types.\r\n\r\n[returns]Returns the direct base types including interfaces[/returns]",
          "ChangeNullability": "Creates a new type that is a copy of this type, with the changed nullability annotation.",
          "GetDefinition": "Gets the underlying type definition.\r\nCan return null for types which do not have a type definition (for example arrays, pointers, type parameters).",
          "GetDefinitionOrUnknown": "Gets the underlying type definition or UnkownType, if unknown.\r\nCan return null for types which do not have a type definition (for example arrays, pointers, type parameters).",
          "AcceptVisitor": "Calls ITypeVisitor.Visit for this type.\r\n\r\n[returns]The return value of the ITypeVisitor.Visit call[/returns]",
          "VisitChildren": "Calls ITypeVisitor.Visit for all children of this type, and reconstructs this type with the children based\r\non the return values of the visit calls.\r\n\r\n[returns]A copy of this type, with all children replaced by the return value of the corresponding visitor call.\r\nIf the visitor returned the original types for all children (or if there are no children), returns [c]this[/c].\r\n[/returns]",
          "GetSubstitution": "Gets a type visitor that performs the substitution of class type parameters with the type arguments\r\nof this parameterized type.\r\nReturns TypeParameterSubstitution.Identity if the type is not parametrized.",
          "GetNestedTypes": "Gets inner classes (including inherited inner classes)\r\nthat have [c]typeArguments.Count[/c] additional type parameters.\r\n\r\n[param name=\u0022typeArguments\u0022]The type arguments passed to the inner class[/param]\r\n[param name=\u0022filter\u0022]The filter used to select which types to return.\r\nThe filter is tested on the original type definitions (before parameterization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nType parameters belonging to the outer class will have the value copied from the outer type\r\nif it is a parameterized type. Otherwise, those existing type parameters will be self-parameterized,\r\nand thus \u0027leaked\u0027 to the caller in the same way the GetMembers() method does not specialize members\r\nfrom an [ICSharpCode.Decompiler.TypeSystem.ITypeDefinition] and \u0027leaks\u0027 type parameters in member signatures.\r\n[/remarks]",
          "GetConstructors": "Gets all instance constructors for this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which constructors to return.\r\nThe filter is tested on the original method definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\n\nThe result does not include static constructors.\r\nConstructors in base classes are not returned by default, as GetMemberOptions.IgnoreInheritedMembers is the default value.\n\r\n\n\r\nFor methods on parameterized types, type substitution will be performed on the method signature,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod] will be returned.\r\n\n\r\n[/remarks]",
          "GetMethods": "Gets all generic methods that can be called on this type with the specified type arguments.\r\n\r\n[param name=\u0022typeArguments\u0022]The type arguments used for the method call.[/param]\r\n[param name=\u0022filter\u0022]The filter used to select which methods to return.\r\nThe filter is tested on the original method definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\n\nThe result does not include constructors or accessors.\n\r\n\n\r\nType substitution will be performed on the method signature, creating a [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod]\r\nwith the specified type arguments.\r\n\n\r\n\n\r\nWhen the list of type arguments is empty, this method acts like the GetMethods() overload without\r\nthe type arguments parameter - that is, it also returns generic methods,\r\nand the other overload\u0027s remarks about ambiguous signatures apply here as well.\r\n\n\r\n[/remarks]",
          "GetProperties": "Gets all properties that can be called on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which properties to return.\r\nThe filter is tested on the original property definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nFor properties on parameterized types, type substitution will be performed on the property signature,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedProperty] will be returned.\r\n[/remarks]",
          "GetFields": "Gets all fields that can be accessed on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which constructors to return.\r\nThe filter is tested on the original field definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nFor fields on parameterized types, type substitution will be performed on the field\u0027s return type,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedField] will be returned.\r\n[/remarks]",
          "GetEvents": "Gets all events that can be accessed on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which events to return.\r\nThe filter is tested on the original event definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nFor fields on parameterized types, type substitution will be performed on the event\u0027s return type,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedEvent] will be returned.\r\n[/remarks]",
          "GetMembers": "Gets all members that can be called on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which members to return.\r\nThe filter is tested on the original member definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\n\n\r\nThe resulting list is the union of GetFields(), GetProperties(), GetMethods() and GetEvents().\r\nIt does not include constructors.\r\nFor parameterized types, type substitution will be performed.\r\n\n\r\n\n\r\nFor generic methods, the remarks about ambiguous signatures from the\r\n[ICSharpCode.Decompiler.TypeSystem.IType.GetMethods(System.Predicate{ICSharpCode.Decompiler.TypeSystem.IMethod},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)] method apply here as well.\r\n\n\r\n[/remarks]",
          "GetAccessors": "Gets all accessors belonging to properties or events on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which members to return.\r\nThe filter is tested on the original member definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nAccessors are not returned by GetMembers() or GetMethods().\r\n[/remarks]"
        },
        "HasOne": {
          "Kind": "TypeKind",
          "Nullability": "Nullability"
        }
      },
      "ITypeDefinition": {
        "Body": "class ITypeDefinition {\n    \u002BIReadOnlyList\u2770ITypeDefinition\u2771 NestedTypes*\n    \u002BIReadOnlyList\u2770IMember\u2771 Members*\n    \u002BIEnumerable\u2770IField\u2771 Fields*\n    \u002BIEnumerable\u2770IMethod\u2771 Methods*\n    \u002BIEnumerable\u2770IProperty\u2771 Properties*\n    \u002BIEnumerable\u2770IEvent\u2771 Events*\n    \u002BIType EnumUnderlyingType*\n    \u002Bbool IsReadOnly*\n    \u002Bstring MetadataName*\n    \u002BIType DeclaringType*\n    \u002Bbool HasExtensionMethods*\n    \u002Bbool IsRecord*\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "ITypeDefinitionOrUnknown": [
            null
          ],
          "IType": [
            null
          ],
          "INamedElement": [
            null
          ],
          "System_IEquatable_T": [
            "IEquatable\u2770IType\u2771"
          ],
          "IEntity": [
            null
          ],
          "ISymbol": [
            null
          ],
          "ICompilationProvider": [
            null
          ]
        },
        "Inherited": {
          "INamedElement": {
            "FlatMembers": "ITypeDefinition : \u002Bstring FullName*\nITypeDefinition : \u002Bstring Name*\nITypeDefinition : \u002Bstring ReflectionName*\nITypeDefinition : \u002Bstring Namespace*"
          },
          "System_IEquatable_T": {
            "FlatMembers": "ITypeDefinition : \u002BEquals(IType other)* bool"
          },
          "IType": {
            "FlatMembers": "ITypeDefinition : \u002Bbool? IsReferenceType*\nITypeDefinition : \u002Bbool IsByRefLike*\nITypeDefinition : \u002BIType DeclaringType*\nITypeDefinition : \u002Bint TypeParameterCount*\nITypeDefinition : \u002BIReadOnlyList\u2770ITypeParameter\u2771 TypeParameters*\nITypeDefinition : \u002BIReadOnlyList\u2770IType\u2771 TypeArguments*\nITypeDefinition : \u002BIEnumerable\u2770IType\u2771 DirectBaseTypes*\nITypeDefinition : \u002BChangeNullability(Nullability newNullability)* IType\nITypeDefinition : \u002BGetDefinition()* ITypeDefinition\nITypeDefinition : \u002BGetDefinitionOrUnknown()* ITypeDefinitionOrUnknown\nITypeDefinition : \u002BAcceptVisitor(TypeVisitor visitor)* IType\nITypeDefinition : \u002BVisitChildren(TypeVisitor visitor)* IType\nITypeDefinition : \u002BGetSubstitution()* TypeParameterSubstitution\nITypeDefinition : \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IType\u2771\nITypeDefinition : \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IType\u2771\nITypeDefinition : \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\nITypeDefinition : \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\nITypeDefinition : \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\nITypeDefinition : \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IProperty\u2771\nITypeDefinition : \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IField\u2771\nITypeDefinition : \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IEvent\u2771\nITypeDefinition : \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMember\u2771\nITypeDefinition : \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771",
            "HasOne": {
              "Kind": "TypeKind",
              "Nullability": "Nullability"
            }
          },
          "ITypeDefinitionOrUnknown": {
            "HasOne": {
              "FullTypeName": "FullTypeName"
            }
          },
          "ISymbol": {
            "FlatMembers": "ITypeDefinition : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          },
          "ICompilationProvider": {
            "FlatMembers": "ITypeDefinition : \u002BICompilation Compilation*"
          },
          "IEntity": {
            "FlatMembers": "ITypeDefinition : \u002BEntityHandle MetadataToken*\nITypeDefinition : \u002Bstring Name*\nITypeDefinition : \u002BITypeDefinition DeclaringTypeDefinition*\nITypeDefinition : \u002BIType DeclaringType*\nITypeDefinition : \u002BIModule ParentModule*\nITypeDefinition : \u002Bbool IsStatic*\nITypeDefinition : \u002Bbool IsAbstract*\nITypeDefinition : \u002Bbool IsSealed*\nITypeDefinition : \u002BGetAttributes()* IEnumerable\u2770IAttribute\u2771\nITypeDefinition : \u002BHasAttribute(KnownAttribute attribute)* bool\nITypeDefinition : \u002BGetAttribute(KnownAttribute attribute)* IAttribute",
            "HasOne": {
              "Accessibility": "Accessibility"
            }
          }
        },
        "XmlDocs": {
          "": "Represents a class, enum, interface, struct, delegate, record or VB module.\r\nFor partial classes, this represents the whole class.",
          "FullName": "Gets the fully qualified name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Collections.Generic.List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment.SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Name": "Gets the short name of the entity.",
          "ReflectionName": "Gets the full reflection name of the element.\r\n\r\n[remarks]\r\nFor types, the reflection name can be parsed back into a ITypeReference by using\r\n[ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)].\r\n[/remarks]\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Int32[][,]\u0022 for C# int[,][][br /]\r\n\u0022System.Collections.Generic.List\u00601[[System.String]]\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment\u002BSpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Namespace": "Gets the full name of the namespace containing this entity.",
          "Kind": "Gets the type kind.",
          "IsReferenceType": "Gets whether the type is a reference type or value type.\r\n\r\n[returns]\r\ntrue, if the type is a reference type.\r\nfalse, if the type is a value type.\r\nnull, if the type is not known (e.g. unconstrained generic type parameter or type not found)\r\n[/returns]",
          "IsByRefLike": "Gets whether this type is \u0022ref-like\u0022: a ByReferenceType or \u0022ref struct\u0022.",
          "Nullability": "Gets the nullability annotation on this type.",
          "DeclaringType": "Gets/Sets the declaring type (incl. type arguments, if any).\r\nThis property will return null for top-level types.",
          "TypeParameterCount": "Gets the number of type parameters.",
          "TypeParameters": "Gets the type parameters.\r\nReturns an empty list if this type is not generic.",
          "TypeArguments": "Gets the type arguments passed to this type.\r\nIf this type is a generic type definition that is not parameterized, this property returns the type parameters,\r\nas if the type was parameterized with its own type arguments ([c]class C\u0026lt;T\u0026gt; { C\u0026lt;T\u0026gt; field; }[/c]).",
          "DirectBaseTypes": "Gets the direct base types.\r\n\r\n[returns]Returns the direct base types including interfaces[/returns]",
          "FullTypeName": "Gets the full name of this type.",
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null.",
          "MetadataToken": "Gets the metadata token for this entity.\r\n\r\n[remarks]\r\nThe token is only valid within the context of the assembly defining this entity.\r\nToken may be 0 if this is a generated member.\r\nNote: specialized members will return the token of the member definition.\r\n[/remarks]",
          "DeclaringTypeDefinition": "Gets the declaring class.\r\nFor members, this is the class that contains the member.\r\nFor nested classes, this is the outer class. For top-level entities, this property returns null.",
          "ParentModule": "The module in which this entity is defined.\r\nMay return null, if the IEntity was not created from a module.",
          "Accessibility": "Gets the accessibility of this entity.",
          "IsStatic": "Gets whether this entity is static.\r\nReturns true if either the \u0027static\u0027 or the \u0027const\u0027 modifier is set.",
          "IsAbstract": "Returns whether this entity is abstract.\r\n\r\n[remarks]Static classes also count as abstract classes.[/remarks]",
          "IsSealed": "Returns whether this entity is sealed.\r\n\r\n[remarks]Static classes also count as sealed classes.[/remarks]",
          "KnownTypeCode": "Gets the known type code for this type definition.",
          "EnumUnderlyingType": "For enums: returns the underlying primitive type.\r\nFor all other types: returns [see langword=\u0022null].",
          "IsReadOnly": "For structs: returns whether this is a readonly struct.\r\nFor all other types: returns false.",
          "MetadataName": "Gets the short type name as stored in metadata.\r\nThat is, the short type name including the generic arity (\u0060N) appended.\r\n\r\n[remarks]\r\n\u0022Int32\u0022 for int\r\n\u0022List\u00601\u0022 for List\u0026lt;T\u0026gt;\r\n\u0022List\u00601\u0022 for List\u0026lt;string\u0026gt;\r\n[/remarks]",
          "HasExtensionMethods": "Gets whether this type contains extension methods.\r\n\r\n[remarks]This property is used to speed up the search for extension methods.[/remarks]",
          "NullableContext": "The nullability specified in the [NullableContext] attribute on the type.\r\nThis serves as default nullability for members of the type that do not have a [Nullable] attribute.",
          "IsRecord": "Gets whether the type has the necessary members to be considered a C# 9 record or C# 10 record struct type.",
          "ChangeNullability": "Creates a new type that is a copy of this type, with the changed nullability annotation.",
          "GetDefinition": "Gets the underlying type definition.\r\nCan return null for types which do not have a type definition (for example arrays, pointers, type parameters).",
          "GetDefinitionOrUnknown": "Gets the underlying type definition or UnkownType, if unknown.\r\nCan return null for types which do not have a type definition (for example arrays, pointers, type parameters).",
          "AcceptVisitor": "Calls ITypeVisitor.Visit for this type.\r\n\r\n[returns]The return value of the ITypeVisitor.Visit call[/returns]",
          "VisitChildren": "Calls ITypeVisitor.Visit for all children of this type, and reconstructs this type with the children based\r\non the return values of the visit calls.\r\n\r\n[returns]A copy of this type, with all children replaced by the return value of the corresponding visitor call.\r\nIf the visitor returned the original types for all children (or if there are no children), returns [c]this[/c].\r\n[/returns]",
          "GetSubstitution": "Gets a type visitor that performs the substitution of class type parameters with the type arguments\r\nof this parameterized type.\r\nReturns TypeParameterSubstitution.Identity if the type is not parametrized.",
          "GetNestedTypes": "Gets inner classes (including inherited inner classes)\r\nthat have [c]typeArguments.Count[/c] additional type parameters.\r\n\r\n[param name=\u0022typeArguments\u0022]The type arguments passed to the inner class[/param]\r\n[param name=\u0022filter\u0022]The filter used to select which types to return.\r\nThe filter is tested on the original type definitions (before parameterization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nType parameters belonging to the outer class will have the value copied from the outer type\r\nif it is a parameterized type. Otherwise, those existing type parameters will be self-parameterized,\r\nand thus \u0027leaked\u0027 to the caller in the same way the GetMembers() method does not specialize members\r\nfrom an [ICSharpCode.Decompiler.TypeSystem.ITypeDefinition] and \u0027leaks\u0027 type parameters in member signatures.\r\n[/remarks]",
          "GetConstructors": "Gets all instance constructors for this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which constructors to return.\r\nThe filter is tested on the original method definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\n\nThe result does not include static constructors.\r\nConstructors in base classes are not returned by default, as GetMemberOptions.IgnoreInheritedMembers is the default value.\n\r\n\n\r\nFor methods on parameterized types, type substitution will be performed on the method signature,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod] will be returned.\r\n\n\r\n[/remarks]",
          "GetMethods": "Gets all generic methods that can be called on this type with the specified type arguments.\r\n\r\n[param name=\u0022typeArguments\u0022]The type arguments used for the method call.[/param]\r\n[param name=\u0022filter\u0022]The filter used to select which methods to return.\r\nThe filter is tested on the original method definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\n\nThe result does not include constructors or accessors.\n\r\n\n\r\nType substitution will be performed on the method signature, creating a [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod]\r\nwith the specified type arguments.\r\n\n\r\n\n\r\nWhen the list of type arguments is empty, this method acts like the GetMethods() overload without\r\nthe type arguments parameter - that is, it also returns generic methods,\r\nand the other overload\u0027s remarks about ambiguous signatures apply here as well.\r\n\n\r\n[/remarks]",
          "GetProperties": "Gets all properties that can be called on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which properties to return.\r\nThe filter is tested on the original property definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nFor properties on parameterized types, type substitution will be performed on the property signature,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedProperty] will be returned.\r\n[/remarks]",
          "GetFields": "Gets all fields that can be accessed on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which constructors to return.\r\nThe filter is tested on the original field definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nFor fields on parameterized types, type substitution will be performed on the field\u0027s return type,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedField] will be returned.\r\n[/remarks]",
          "GetEvents": "Gets all events that can be accessed on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which events to return.\r\nThe filter is tested on the original event definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nFor fields on parameterized types, type substitution will be performed on the event\u0027s return type,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedEvent] will be returned.\r\n[/remarks]",
          "GetMembers": "Gets all members that can be called on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which members to return.\r\nThe filter is tested on the original member definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\n\n\r\nThe resulting list is the union of GetFields(), GetProperties(), GetMethods() and GetEvents().\r\nIt does not include constructors.\r\nFor parameterized types, type substitution will be performed.\r\n\n\r\n\n\r\nFor generic methods, the remarks about ambiguous signatures from the\r\n[ICSharpCode.Decompiler.TypeSystem.IType.GetMethods(System.Predicate{ICSharpCode.Decompiler.TypeSystem.IMethod},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)] method apply here as well.\r\n\n\r\n[/remarks]",
          "GetAccessors": "Gets all accessors belonging to properties or events on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which members to return.\r\nThe filter is tested on the original member definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nAccessors are not returned by GetMembers() or GetMethods().\r\n[/remarks]",
          "GetAttributes": "Gets the attributes on this entity.\r\nDoes not include inherited attributes."
        },
        "HasOne": {
          "KnownTypeCode": "KnownTypeCode",
          "NullableContext": "Nullability"
        }
      },
      "ITypeDefinitionOrUnknown": {
        "Body": "class ITypeDefinitionOrUnknown {\n    \n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "IType": [
            null
          ],
          "INamedElement": [
            null
          ],
          "System_IEquatable_T": [
            "IEquatable\u2770IType\u2771"
          ]
        },
        "Inherited": {
          "INamedElement": {
            "FlatMembers": "ITypeDefinitionOrUnknown : \u002Bstring FullName*\nITypeDefinitionOrUnknown : \u002Bstring Name*\nITypeDefinitionOrUnknown : \u002Bstring ReflectionName*\nITypeDefinitionOrUnknown : \u002Bstring Namespace*"
          },
          "System_IEquatable_T": {
            "FlatMembers": "ITypeDefinitionOrUnknown : \u002BEquals(IType other)* bool"
          },
          "IType": {
            "FlatMembers": "ITypeDefinitionOrUnknown : \u002Bbool? IsReferenceType*\nITypeDefinitionOrUnknown : \u002Bbool IsByRefLike*\nITypeDefinitionOrUnknown : \u002BIType DeclaringType*\nITypeDefinitionOrUnknown : \u002Bint TypeParameterCount*\nITypeDefinitionOrUnknown : \u002BIReadOnlyList\u2770ITypeParameter\u2771 TypeParameters*\nITypeDefinitionOrUnknown : \u002BIReadOnlyList\u2770IType\u2771 TypeArguments*\nITypeDefinitionOrUnknown : \u002BIEnumerable\u2770IType\u2771 DirectBaseTypes*\nITypeDefinitionOrUnknown : \u002BChangeNullability(Nullability newNullability)* IType\nITypeDefinitionOrUnknown : \u002BGetDefinition()* ITypeDefinition\nITypeDefinitionOrUnknown : \u002BGetDefinitionOrUnknown()* ITypeDefinitionOrUnknown\nITypeDefinitionOrUnknown : \u002BAcceptVisitor(TypeVisitor visitor)* IType\nITypeDefinitionOrUnknown : \u002BVisitChildren(TypeVisitor visitor)* IType\nITypeDefinitionOrUnknown : \u002BGetSubstitution()* TypeParameterSubstitution\nITypeDefinitionOrUnknown : \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IType\u2771\nITypeDefinitionOrUnknown : \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IType\u2771\nITypeDefinitionOrUnknown : \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\nITypeDefinitionOrUnknown : \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\nITypeDefinitionOrUnknown : \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\nITypeDefinitionOrUnknown : \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IProperty\u2771\nITypeDefinitionOrUnknown : \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IField\u2771\nITypeDefinitionOrUnknown : \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IEvent\u2771\nITypeDefinitionOrUnknown : \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMember\u2771\nITypeDefinitionOrUnknown : \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771",
            "HasOne": {
              "Kind": "TypeKind",
              "Nullability": "Nullability"
            }
          }
        },
        "XmlDocs": {
          "": "Represents a class, enum, interface, struct, delegate, record or unknown type.\r\nFor partial classes, this represents the whole class.",
          "FullName": "Gets the fully qualified name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Collections.Generic.List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment.SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Name": "Gets the short name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022Int32[]\u0022 for int[][br /]\r\n\u0022List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "ReflectionName": "Gets the full reflection name of the element.\r\n\r\n[remarks]\r\nFor types, the reflection name can be parsed back into a ITypeReference by using\r\n[ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)].\r\n[/remarks]\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Int32[][,]\u0022 for C# int[,][][br /]\r\n\u0022System.Collections.Generic.List\u00601[[System.String]]\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment\u002BSpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Namespace": "Gets the full name of the namespace containing this entity.",
          "Kind": "Gets the type kind.",
          "IsReferenceType": "Gets whether the type is a reference type or value type.\r\n\r\n[returns]\r\ntrue, if the type is a reference type.\r\nfalse, if the type is a value type.\r\nnull, if the type is not known (e.g. unconstrained generic type parameter or type not found)\r\n[/returns]",
          "IsByRefLike": "Gets whether this type is \u0022ref-like\u0022: a ByReferenceType or \u0022ref struct\u0022.",
          "Nullability": "Gets the nullability annotation on this type.",
          "DeclaringType": "Gets the parent type, if this is a nested type.\r\nReturns null for top-level types.",
          "TypeParameterCount": "Gets the number of type parameters.",
          "TypeParameters": "Gets the type parameters.\r\nReturns an empty list if this type is not generic.",
          "TypeArguments": "Gets the type arguments passed to this type.\r\nIf this type is a generic type definition that is not parameterized, this property returns the type parameters,\r\nas if the type was parameterized with its own type arguments ([c]class C\u0026lt;T\u0026gt; { C\u0026lt;T\u0026gt; field; }[/c]).",
          "DirectBaseTypes": "Gets the direct base types.\r\n\r\n[returns]Returns the direct base types including interfaces[/returns]",
          "FullTypeName": "Gets the full name of this type.",
          "ChangeNullability": "Creates a new type that is a copy of this type, with the changed nullability annotation.",
          "GetDefinition": "Gets the underlying type definition.\r\nCan return null for types which do not have a type definition (for example arrays, pointers, type parameters).",
          "GetDefinitionOrUnknown": "Gets the underlying type definition or UnkownType, if unknown.\r\nCan return null for types which do not have a type definition (for example arrays, pointers, type parameters).",
          "AcceptVisitor": "Calls ITypeVisitor.Visit for this type.\r\n\r\n[returns]The return value of the ITypeVisitor.Visit call[/returns]",
          "VisitChildren": "Calls ITypeVisitor.Visit for all children of this type, and reconstructs this type with the children based\r\non the return values of the visit calls.\r\n\r\n[returns]A copy of this type, with all children replaced by the return value of the corresponding visitor call.\r\nIf the visitor returned the original types for all children (or if there are no children), returns [c]this[/c].\r\n[/returns]",
          "GetSubstitution": "Gets a type visitor that performs the substitution of class type parameters with the type arguments\r\nof this parameterized type.\r\nReturns TypeParameterSubstitution.Identity if the type is not parametrized.",
          "GetNestedTypes": "Gets inner classes (including inherited inner classes)\r\nthat have [c]typeArguments.Count[/c] additional type parameters.\r\n\r\n[param name=\u0022typeArguments\u0022]The type arguments passed to the inner class[/param]\r\n[param name=\u0022filter\u0022]The filter used to select which types to return.\r\nThe filter is tested on the original type definitions (before parameterization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nType parameters belonging to the outer class will have the value copied from the outer type\r\nif it is a parameterized type. Otherwise, those existing type parameters will be self-parameterized,\r\nand thus \u0027leaked\u0027 to the caller in the same way the GetMembers() method does not specialize members\r\nfrom an [ICSharpCode.Decompiler.TypeSystem.ITypeDefinition] and \u0027leaks\u0027 type parameters in member signatures.\r\n[/remarks]",
          "GetConstructors": "Gets all instance constructors for this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which constructors to return.\r\nThe filter is tested on the original method definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\n\nThe result does not include static constructors.\r\nConstructors in base classes are not returned by default, as GetMemberOptions.IgnoreInheritedMembers is the default value.\n\r\n\n\r\nFor methods on parameterized types, type substitution will be performed on the method signature,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod] will be returned.\r\n\n\r\n[/remarks]",
          "GetMethods": "Gets all generic methods that can be called on this type with the specified type arguments.\r\n\r\n[param name=\u0022typeArguments\u0022]The type arguments used for the method call.[/param]\r\n[param name=\u0022filter\u0022]The filter used to select which methods to return.\r\nThe filter is tested on the original method definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\n\nThe result does not include constructors or accessors.\n\r\n\n\r\nType substitution will be performed on the method signature, creating a [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod]\r\nwith the specified type arguments.\r\n\n\r\n\n\r\nWhen the list of type arguments is empty, this method acts like the GetMethods() overload without\r\nthe type arguments parameter - that is, it also returns generic methods,\r\nand the other overload\u0027s remarks about ambiguous signatures apply here as well.\r\n\n\r\n[/remarks]",
          "GetProperties": "Gets all properties that can be called on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which properties to return.\r\nThe filter is tested on the original property definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nFor properties on parameterized types, type substitution will be performed on the property signature,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedProperty] will be returned.\r\n[/remarks]",
          "GetFields": "Gets all fields that can be accessed on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which constructors to return.\r\nThe filter is tested on the original field definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nFor fields on parameterized types, type substitution will be performed on the field\u0027s return type,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedField] will be returned.\r\n[/remarks]",
          "GetEvents": "Gets all events that can be accessed on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which events to return.\r\nThe filter is tested on the original event definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nFor fields on parameterized types, type substitution will be performed on the event\u0027s return type,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedEvent] will be returned.\r\n[/remarks]",
          "GetMembers": "Gets all members that can be called on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which members to return.\r\nThe filter is tested on the original member definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\n\n\r\nThe resulting list is the union of GetFields(), GetProperties(), GetMethods() and GetEvents().\r\nIt does not include constructors.\r\nFor parameterized types, type substitution will be performed.\r\n\n\r\n\n\r\nFor generic methods, the remarks about ambiguous signatures from the\r\n[ICSharpCode.Decompiler.TypeSystem.IType.GetMethods(System.Predicate{ICSharpCode.Decompiler.TypeSystem.IMethod},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)] method apply here as well.\r\n\n\r\n[/remarks]",
          "GetAccessors": "Gets all accessors belonging to properties or events on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which members to return.\r\nThe filter is tested on the original member definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nAccessors are not returned by GetMembers() or GetMethods().\r\n[/remarks]"
        },
        "HasOne": {
          "FullTypeName": "FullTypeName"
        }
      },
      "ITypeParameter": {
        "Body": "class ITypeParameter {\n    \u002BIEntity Owner*\n    \u002Bint Index*\n    \u002Bstring Name*\n    \u002BIType EffectiveBaseClass*\n    \u002BIReadOnlyCollection\u2770IType\u2771 EffectiveInterfaceSet*\n    \u002Bbool HasDefaultConstructorConstraint*\n    \u002Bbool HasReferenceTypeConstraint*\n    \u002Bbool HasValueTypeConstraint*\n    \u002Bbool HasUnmanagedConstraint*\n    \u002BGetAttributes()* IEnumerable\u2770IAttribute\u2771\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "IType": [
            null
          ],
          "INamedElement": [
            null
          ],
          "System_IEquatable_T": [
            "IEquatable\u2770IType\u2771"
          ],
          "ISymbol": [
            null
          ]
        },
        "Inherited": {
          "INamedElement": {
            "FlatMembers": "ITypeParameter : \u002Bstring FullName*\nITypeParameter : \u002Bstring Name*\nITypeParameter : \u002Bstring ReflectionName*\nITypeParameter : \u002Bstring Namespace*"
          },
          "System_IEquatable_T": {
            "FlatMembers": "ITypeParameter : \u002BEquals(IType other)* bool"
          },
          "IType": {
            "FlatMembers": "ITypeParameter : \u002Bbool? IsReferenceType*\nITypeParameter : \u002Bbool IsByRefLike*\nITypeParameter : \u002BIType DeclaringType*\nITypeParameter : \u002Bint TypeParameterCount*\nITypeParameter : \u002BIReadOnlyList\u2770ITypeParameter\u2771 TypeParameters*\nITypeParameter : \u002BIReadOnlyList\u2770IType\u2771 TypeArguments*\nITypeParameter : \u002BIEnumerable\u2770IType\u2771 DirectBaseTypes*\nITypeParameter : \u002BChangeNullability(Nullability newNullability)* IType\nITypeParameter : \u002BGetDefinition()* ITypeDefinition\nITypeParameter : \u002BGetDefinitionOrUnknown()* ITypeDefinitionOrUnknown\nITypeParameter : \u002BAcceptVisitor(TypeVisitor visitor)* IType\nITypeParameter : \u002BVisitChildren(TypeVisitor visitor)* IType\nITypeParameter : \u002BGetSubstitution()* TypeParameterSubstitution\nITypeParameter : \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IType\u2771\nITypeParameter : \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IType\u2771\nITypeParameter : \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\nITypeParameter : \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\nITypeParameter : \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771\nITypeParameter : \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IProperty\u2771\nITypeParameter : \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IField\u2771\nITypeParameter : \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IEvent\u2771\nITypeParameter : \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMember\u2771\nITypeParameter : \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options)* IEnumerable\u2770IMethod\u2771",
            "HasOne": {
              "Kind": "TypeKind",
              "Nullability": "Nullability"
            }
          },
          "ISymbol": {
            "FlatMembers": "ITypeParameter : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          }
        },
        "XmlDocs": {
          "": "Type parameter of a generic class/method.",
          "FullName": "Gets the fully qualified name of the class the return type is pointing to.\r\n\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Collections.Generic.List\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment.SpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Name": "Gets the name of the type parameter.",
          "ReflectionName": "Gets the full reflection name of the element.\r\n\r\n[remarks]\r\nFor types, the reflection name can be parsed back into a ITypeReference by using\r\n[ICSharpCode.Decompiler.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)].\r\n[/remarks]\r\n[returns]\r\n\u0022System.Int32[]\u0022 for int[][br /]\r\n\u0022System.Int32[][,]\u0022 for C# int[,][][br /]\r\n\u0022System.Collections.Generic.List\u00601[[System.String]]\u0022 for List\u0026lt;string\u0026gt;\r\n\u0022System.Environment\u002BSpecialFolder\u0022 for Environment.SpecialFolder\r\n[/returns]",
          "Namespace": "Gets the full name of the namespace containing this entity.",
          "Kind": "Gets the type kind.",
          "IsReferenceType": "Gets whether the type is a reference type or value type.\r\n\r\n[returns]\r\ntrue, if the type is a reference type.\r\nfalse, if the type is a value type.\r\nnull, if the type is not known (e.g. unconstrained generic type parameter or type not found)\r\n[/returns]",
          "IsByRefLike": "Gets whether this type is \u0022ref-like\u0022: a ByReferenceType or \u0022ref struct\u0022.",
          "Nullability": "Gets the nullability annotation on this type.",
          "DeclaringType": "Gets the parent type, if this is a nested type.\r\nReturns null for top-level types.",
          "TypeParameterCount": "Gets the number of type parameters.",
          "TypeParameters": "Gets the type parameters.\r\nReturns an empty list if this type is not generic.",
          "TypeArguments": "Gets the type arguments passed to this type.\r\nIf this type is a generic type definition that is not parameterized, this property returns the type parameters,\r\nas if the type was parameterized with its own type arguments ([c]class C\u0026lt;T\u0026gt; { C\u0026lt;T\u0026gt; field; }[/c]).",
          "DirectBaseTypes": "Gets the direct base types.\r\n\r\n[returns]Returns the direct base types including interfaces[/returns]",
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "OwnerType": "Get the type of this type parameter\u0027s owner.\r\n\r\n[returns]SymbolKind.TypeDefinition or SymbolKind.Method[/returns]",
          "Owner": "Gets the owning method/class.\r\nThis property may return null (for example for the dummy type parameters used by [ICSharpCode.Decompiler.TypeSystem.NormalizeTypeVisitor.ReplaceMethodTypeParametersWithDummy]).\r\n\r\n[remarks]\r\nFor \u0022class Outer\u0026lt;T\u0026gt; { class Inner {} }\u0022,\r\ninner.TypeParameters[0].Owner will be the outer class, because the same\r\nITypeParameter instance is used both on Outer\u00601 and Outer\u00601\u002BInner.\r\n[/remarks]",
          "Index": "Gets the index of the type parameter in the type parameter list of the owning method/class.",
          "Variance": "Gets the variance of this type parameter.",
          "EffectiveBaseClass": "Gets the effective base class of this type parameter.",
          "EffectiveInterfaceSet": "Gets the effective interface set of this type parameter.",
          "HasDefaultConstructorConstraint": "Gets if the type parameter has the \u0027new()\u0027 constraint.",
          "HasReferenceTypeConstraint": "Gets if the type parameter has the \u0027class\u0027 constraint.",
          "HasValueTypeConstraint": "Gets if the type parameter has the \u0027struct\u0027 or \u0027unmanaged\u0027 constraint.",
          "HasUnmanagedConstraint": "Gets if the type parameter has the \u0027unmanaged\u0027 constraint.",
          "NullabilityConstraint": "Nullability of the reference type constraint. (e.g. \u0022where T : class?\u0022).\r\n\r\nNote that the nullability of a use of the type parameter may differ from this.\r\nE.g. \u0022T? GetNull\u0026lt;T\u0026gt;() where T : class =\u0026gt; null;\u0022",
          "ChangeNullability": "Creates a new type that is a copy of this type, with the changed nullability annotation.",
          "GetDefinition": "Gets the underlying type definition.\r\nCan return null for types which do not have a type definition (for example arrays, pointers, type parameters).",
          "GetDefinitionOrUnknown": "Gets the underlying type definition or UnkownType, if unknown.\r\nCan return null for types which do not have a type definition (for example arrays, pointers, type parameters).",
          "AcceptVisitor": "Calls ITypeVisitor.Visit for this type.\r\n\r\n[returns]The return value of the ITypeVisitor.Visit call[/returns]",
          "VisitChildren": "Calls ITypeVisitor.Visit for all children of this type, and reconstructs this type with the children based\r\non the return values of the visit calls.\r\n\r\n[returns]A copy of this type, with all children replaced by the return value of the corresponding visitor call.\r\nIf the visitor returned the original types for all children (or if there are no children), returns [c]this[/c].\r\n[/returns]",
          "GetSubstitution": "Gets a type visitor that performs the substitution of class type parameters with the type arguments\r\nof this parameterized type.\r\nReturns TypeParameterSubstitution.Identity if the type is not parametrized.",
          "GetNestedTypes": "Gets inner classes (including inherited inner classes)\r\nthat have [c]typeArguments.Count[/c] additional type parameters.\r\n\r\n[param name=\u0022typeArguments\u0022]The type arguments passed to the inner class[/param]\r\n[param name=\u0022filter\u0022]The filter used to select which types to return.\r\nThe filter is tested on the original type definitions (before parameterization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nType parameters belonging to the outer class will have the value copied from the outer type\r\nif it is a parameterized type. Otherwise, those existing type parameters will be self-parameterized,\r\nand thus \u0027leaked\u0027 to the caller in the same way the GetMembers() method does not specialize members\r\nfrom an [ICSharpCode.Decompiler.TypeSystem.ITypeDefinition] and \u0027leaks\u0027 type parameters in member signatures.\r\n[/remarks]",
          "GetConstructors": "Gets all instance constructors for this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which constructors to return.\r\nThe filter is tested on the original method definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\n\nThe result does not include static constructors.\r\nConstructors in base classes are not returned by default, as GetMemberOptions.IgnoreInheritedMembers is the default value.\n\r\n\n\r\nFor methods on parameterized types, type substitution will be performed on the method signature,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod] will be returned.\r\n\n\r\n[/remarks]",
          "GetMethods": "Gets all generic methods that can be called on this type with the specified type arguments.\r\n\r\n[param name=\u0022typeArguments\u0022]The type arguments used for the method call.[/param]\r\n[param name=\u0022filter\u0022]The filter used to select which methods to return.\r\nThe filter is tested on the original method definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\n\nThe result does not include constructors or accessors.\n\r\n\n\r\nType substitution will be performed on the method signature, creating a [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod]\r\nwith the specified type arguments.\r\n\n\r\n\n\r\nWhen the list of type arguments is empty, this method acts like the GetMethods() overload without\r\nthe type arguments parameter - that is, it also returns generic methods,\r\nand the other overload\u0027s remarks about ambiguous signatures apply here as well.\r\n\n\r\n[/remarks]",
          "GetProperties": "Gets all properties that can be called on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which properties to return.\r\nThe filter is tested on the original property definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nFor properties on parameterized types, type substitution will be performed on the property signature,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedProperty] will be returned.\r\n[/remarks]",
          "GetFields": "Gets all fields that can be accessed on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which constructors to return.\r\nThe filter is tested on the original field definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nFor fields on parameterized types, type substitution will be performed on the field\u0027s return type,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedField] will be returned.\r\n[/remarks]",
          "GetEvents": "Gets all events that can be accessed on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which events to return.\r\nThe filter is tested on the original event definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nFor fields on parameterized types, type substitution will be performed on the event\u0027s return type,\r\nand the appropriate [ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedEvent] will be returned.\r\n[/remarks]",
          "GetMembers": "Gets all members that can be called on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which members to return.\r\nThe filter is tested on the original member definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\n\n\r\nThe resulting list is the union of GetFields(), GetProperties(), GetMethods() and GetEvents().\r\nIt does not include constructors.\r\nFor parameterized types, type substitution will be performed.\r\n\n\r\n\n\r\nFor generic methods, the remarks about ambiguous signatures from the\r\n[ICSharpCode.Decompiler.TypeSystem.IType.GetMethods(System.Predicate{ICSharpCode.Decompiler.TypeSystem.IMethod},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)] method apply here as well.\r\n\n\r\n[/remarks]",
          "GetAccessors": "Gets all accessors belonging to properties or events on this type.\r\n\r\n[param name=\u0022filter\u0022]The filter used to select which members to return.\r\nThe filter is tested on the original member definitions (before specialization).[/param]\r\n[param name=\u0022options\u0022]Specified additional options for the GetMembers() operation.[/param]\r\n[remarks]\r\nAccessors are not returned by GetMembers() or GetMethods().\r\n[/remarks]",
          "GetAttributes": "Gets the attributes declared on this type parameter."
        },
        "HasOne": {
          "OwnerType": "SymbolKind",
          "Variance": "VarianceModifier",
          "NullabilityConstraint": "Nullability"
        },
        "HasMany": {
          "TypeConstraints": "TypeConstraint"
        }
      },
      "ITypeReference": {
        "Body": "class ITypeReference {\n    \u002BResolve(ITypeResolveContext context)* IType\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Represents a reference to a type.\r\nMust be resolved before it can be used as type.",
          "Resolve": "Resolves this type reference.\r\n\r\n[param name=\u0022context\u0022]\r\nContext to use for resolving this type reference.\r\nWhich kind of context is required depends on the which kind of type reference this is;\r\nplease consult the documentation of the method that was used to create this type reference,\r\nor that of the class implementing this method.\r\n[/param]\r\n[returns]\r\nReturns the resolved type.\r\nIn case of an error, returns an unknown type ([ICSharpCode.Decompiler.TypeSystem.TypeKind.Unknown]).\r\nNever returns null.\r\n[/returns]"
        }
      },
      "ITypeResolveContext": {
        "Body": "class ITypeResolveContext {\n    \u002BIModule CurrentModule*\n    \u002BITypeDefinition CurrentTypeDefinition*\n    \u002BIMember CurrentMember*\n    \u002BWithCurrentTypeDefinition(ITypeDefinition typeDefinition)* ITypeResolveContext\n    \u002BWithCurrentMember(IMember member)* ITypeResolveContext\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "ICompilationProvider": [
            null
          ]
        },
        "Inherited": {
          "ICompilationProvider": {
            "FlatMembers": "ITypeResolveContext : \u002BICompilation Compilation*"
          }
        },
        "XmlDocs": {
          "Compilation": "Gets the parent compilation.\r\nThis property never returns null.",
          "CurrentModule": "Gets the current module.\r\nThis property may return null if this context does not specify any module.",
          "CurrentTypeDefinition": "Gets the current type definition.",
          "CurrentMember": "Gets the current member."
        }
      },
      "IVariable": {
        "Body": "class IVariable {\n    \u002Bstring Name*\n    \u002BIType Type*\n    \u002Bbool IsConst*\n    \u002BGetConstantValue(bool throwOnInvalidMetadata)* object\n    \u003C\u003CInterface\u003E\u003E\n}",
        "Interfaces": {
          "ISymbol": [
            null
          ]
        },
        "Inherited": {
          "ISymbol": {
            "FlatMembers": "IVariable : \u002Bstring Name*",
            "HasOne": {
              "SymbolKind": "SymbolKind"
            }
          }
        },
        "XmlDocs": {
          "": "Represents a variable (name/type pair).",
          "SymbolKind": "This property returns an enum specifying which kind of symbol this is\r\n(which derived interfaces of ISymbol are implemented)",
          "Name": "Gets the name of the variable.",
          "Type": "Gets the type of the variable.",
          "IsConst": "Gets whether this variable is a constant (C#-like const).",
          "GetConstantValue": "If this field is a constant, retrieves the value.\r\nFor parameters, this is the default value."
        }
      },
      "InheritanceHelper": {
        "Body": "class InheritanceHelper {\n    \u002BGetBaseMember(IMember member)$ IMember\n    \u002BGetBaseMembers(IMember member, bool includeImplementedInterfaces)$ IEnumerable\u2770IMember\u2771\n    \u002BGetDerivedMember(IMember baseMember, ITypeDefinition derivedType)$ IMember\n    ~GetAttributes(ITypeDefinition typeDef)$ IEnumerable\u2770IAttribute\u2771\n    ~GetAttribute(ITypeDefinition typeDef, KnownAttribute attributeType)$ IAttribute\n    ~GetAttributes(IMember member)$ IEnumerable\u2770IAttribute\u2771\n    ~GetAttribute(IMember member, KnownAttribute attributeType)$ IAttribute\n    \u003C\u003CService\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Provides helper methods for inheritance.",
          "GetBaseMember": "Gets the base member that has the same signature.",
          "GetBaseMembers": "Gets all base members that have the same signature.\r\n\r\n[returns]\r\nList of base members with the same signature. The member from the derived-most base class is returned first.\r\n[/returns]",
          "GetDerivedMember": "Finds the member declared in \u0027derivedType\u0027 that has the same signature (could override) \u0027baseMember\u0027."
        }
      },
      "InterningProvider": {
        "Body": "class InterningProvider {\n    \u002BIntern(ISupportsInterning obj)* ISupportsInterning\n    \u002BIntern\u2770T\u2771(T obj) T\n    \u002BIntern(string text)* string\n    \u002BInternValue(object obj)* object\n    \u002BInternList\u2770T\u2771(IList\u2770T\u2771 list)* IList\u2770T\u2771\n    \u002BInterningProvider Dummy$\n    \u003C\u003CAbstract\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Provider used for interning.\r\n\r\n[remarks]\r\nA simple IInterningProvider implementation could use 3 dictionaries:\r\n1. using value equality comparer (for certain types known to implement value equality, e.g. string and IType)\r\n2. using comparer that calls into ISupportsInterning (for types implementing ISupportsInterning)\r\n3. list comparer (for InternList method)\r\n\r\nOn the first Intern()-call, the provider tells the object to prepare for interning (ISupportsInterning.PrepareForInterning)\r\nand stores it into a dictionary. On further Intern() calls, the original object is returned for all equal objects.\r\nThis allows reducing the memory usage by using a single object instance where possible.\r\n\r\nInterning provider implementations could also use the interning logic for different purposes:\r\nfor example, it could be used to determine which objects are used jointly between multiple type definitions\r\nand which are used only within a single type definition. Then a persistent file format could be organized so\r\nthat shared objects are loaded only once, yet non-shared objects get loaded lazily together with the class.\r\n[/remarks]",
          "Intern": "Interns the specified string.",
          "InternValue": "Inters a boxed value type.",
          "InternList": "Interns the given list. Uses reference equality to compare the list elements."
        }
      },
      "DummyInterningProvider": {
        "Name": "InterningProvider\u002BDummyInterningProvider",
        "Body": "class DummyInterningProvider {\n    \u002BIntern(ISupportsInterning obj) ISupportsInterning\n    \u002BIntern(string text) string\n    \u002BInternValue(object obj) object\n    \u002BInternList\u2770T\u2771(IList\u2770T\u2771 list) IList\u2770T\u2771\n}",
        "BaseType": {
          "InterningProvider": null
        },
        "Inherited": {
          "InterningProvider": {
            "FlatMembers": "DummyInterningProvider : \u002BIntern(ISupportsInterning obj)* ISupportsInterning\nDummyInterningProvider : \u002BIntern\u2770T\u2771(T obj) T\nDummyInterningProvider : \u002BIntern(string text)* string\nDummyInterningProvider : \u002BInternValue(object obj)* object\nDummyInterningProvider : \u002BInternList\u2770T\u2771(IList\u2770T\u2771 list)* IList\u2770T\u2771\nDummyInterningProvider : \u002BInterningProvider Dummy$"
          }
        },
        "XmlDocs": {
          "Intern": "Interns the specified string.",
          "InternValue": "Inters a boxed value type.",
          "InternList": "Interns the given list. Uses reference equality to compare the list elements."
        }
      },
      "IntersectionType": {
        "Body": "class IntersectionType {\n    \u002Bstring Name\n    \u002Bstring ReflectionName\n    \u002Bbool? IsReferenceType\n    \u002BCreate(IEnumerable\u2770IType\u2771 types)$ IType\n    \u002BGetHashCode() int\n    \u002BEquals(IType other) bool\n    \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options) IEnumerable\u2770IProperty\u2771\n    \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options) IEnumerable\u2770IField\u2771\n    \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options) IEnumerable\u2770IEvent\u2771\n    \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMember\u2771\n    \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    -FilterNonStatic\u2770T\u2771(Predicate\u2770T\u2771 filter)$ Predicate\u2770T\u2771\n}",
        "BaseType": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_AbstractType": null
        },
        "Inherited": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_AbstractType": {
            "FlatMembers": "IntersectionType : \u002Bstring FullName\nIntersectionType : \u002Bstring Name*\nIntersectionType : \u002Bstring Namespace\nIntersectionType : \u002Bstring ReflectionName\nIntersectionType : \u002Bbool? IsReferenceType*\nIntersectionType : \u002Bbool IsByRefLike\nIntersectionType : \u002Bint TypeParameterCount\nIntersectionType : \u002BChangeNullability(Nullability nullability) IType\nIntersectionType : \u002BGetDefinition() ITypeDefinition\nIntersectionType : \u002BGetDefinitionOrUnknown() ITypeDefinitionOrUnknown\nIntersectionType : \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nIntersectionType : \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nIntersectionType : \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nIntersectionType : \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nIntersectionType : \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nIntersectionType : \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options) IEnumerable\u2770IProperty\u2771\nIntersectionType : \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options) IEnumerable\u2770IField\u2771\nIntersectionType : \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options) IEnumerable\u2770IEvent\u2771\nIntersectionType : \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMember\u2771\nIntersectionType : \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nIntersectionType : \u002BGetSubstitution() TypeParameterSubstitution\nIntersectionType : \u002BGetSubstitution(IReadOnlyList\u2770IType\u2771 methodTypeArguments) TypeParameterSubstitution\nIntersectionType : \u002BEquals(IType other) bool\nIntersectionType : \u002BAcceptVisitor(TypeVisitor visitor) IType\nIntersectionType : \u002BVisitChildren(TypeVisitor visitor) IType",
            "HasOne": {
              "Nullability": "Nullability",
              "Kind": "TypeKind",
              "DeclaringType": "IType"
            },
            "HasMany": {
              "TypeParameters": "ITypeParameter",
              "TypeArguments": "IType",
              "DirectBaseTypes": "IType"
            }
          }
        },
        "XmlDocs": {
          "": "Represents the intersection of several types."
        },
        "HasOne": {
          "Kind": "TypeKind"
        },
        "HasMany": {
          "Types": "IType",
          "DirectBaseTypes": "IType"
        }
      },
      "KnownAttribute": {
        "Body": "class KnownAttribute {\n    \u003C\u003CEnumeration\u003E\u003E\n    None\n    CompilerGenerated\n    CompilerFeatureRequired\n    Extension\n    Dynamic\n    TupleElementNames\n    Nullable\n    NullableContext\n    NullablePublicOnly\n    Conditional\n    Obsolete\n    Embedded\n    IsReadOnly\n    SpecialName\n    DebuggerHidden\n    DebuggerStepThrough\n    DebuggerBrowsable\n    AssemblyVersion\n    InternalsVisibleTo\n    TypeForwardedTo\n    ReferenceAssembly\n    Serializable\n    Flags\n    ComImport\n    CoClass\n    StructLayout\n    DefaultMember\n    IsByRefLike\n    IteratorStateMachine\n    AsyncStateMachine\n    AsyncMethodBuilder\n    AsyncIteratorStateMachine\n    FieldOffset\n    NonSerialized\n    DecimalConstant\n    FixedBuffer\n    DllImport\n    PreserveSig\n    MethodImpl\n    IndexerName\n    ParamArray\n    In\n    Out\n    Optional\n    DefaultParameterValue\n    CallerMemberName\n    CallerFilePath\n    CallerLineNumber\n    ScopedRef\n    RequiresLocation\n    IsUnmanaged\n    MarshalAs\n    PermissionSet\n    NativeInteger\n    PreserveBaseOverrides\n    RequiredAttribute\n}",
        "XmlDocs": {
          "None": "Not a known attribute",
          "Extension": "Marks a method as extension method; or a class as containing extension methods."
        }
      },
      "KnownAttributes": {
        "Body": "class KnownAttributes {\n    \u002BGetTypeName(KnownAttribute attr)$ \u0026TopLevelTypeName\n    \u002BFindType(ICompilation compilation, KnownAttribute attrType)$ IType\n    \u002BIsKnownAttributeType(ITypeDefinition attributeType)$ KnownAttribute\n    \u002BIsCustomAttribute(KnownAttribute knownAttribute)$ bool\n    ~int Count$\n    -TopLevelTypeName[] typeNames$\n    \u003C\u003CService\u003E\u003E\n}",
        "Inherited": {}
      },
      "KnownTypeCode": {
        "Body": "class KnownTypeCode {\n    \u003C\u003CEnumeration\u003E\u003E\n    None\n    Object\n    DBNull\n    Boolean\n    Char\n    SByte\n    Byte\n    Int16\n    UInt16\n    Int32\n    UInt32\n    Int64\n    UInt64\n    Single\n    Double\n    Decimal\n    DateTime\n    String\n    Void\n    Type\n    Array\n    Attribute\n    ValueType\n    Enum\n    Delegate\n    MulticastDelegate\n    Exception\n    IntPtr\n    UIntPtr\n    IEnumerable\n    IEnumerator\n    IEnumerableOfT\n    IEnumeratorOfT\n    ICollection\n    ICollectionOfT\n    IList\n    IListOfT\n    IReadOnlyCollectionOfT\n    IReadOnlyListOfT\n    Task\n    TaskOfT\n    ValueTask\n    ValueTaskOfT\n    NullableOfT\n    IDisposable\n    IAsyncDisposable\n    INotifyCompletion\n    ICriticalNotifyCompletion\n    TypedReference\n    IFormattable\n    FormattableString\n    DefaultInterpolatedStringHandler\n    SpanOfT\n    ReadOnlySpanOfT\n    MemoryOfT\n    Unsafe\n    IAsyncEnumerableOfT\n    IAsyncEnumeratorOfT\n    Index\n    Range\n}",
        "XmlDocs": {
          "": "Represents some well-known types.",
          "None": "Not one of the known types.",
          "Object": "[c]object[/c] (System.Object)",
          "DBNull": "[c]System.DBNull[/c]",
          "Boolean": "[c]bool[/c] (System.Boolean)",
          "Char": "[c]char[/c] (System.Char)",
          "SByte": "[c]sbyte[/c] (System.SByte)",
          "Byte": "[c]byte[/c] (System.Byte)",
          "Int16": "[c]short[/c] (System.Int16)",
          "UInt16": "[c]ushort[/c] (System.UInt16)",
          "Int32": "[c]int[/c] (System.Int32)",
          "UInt32": "[c]uint[/c] (System.UInt32)",
          "Int64": "[c]long[/c] (System.Int64)",
          "UInt64": "[c]ulong[/c] (System.UInt64)",
          "Single": "[c]float[/c] (System.Single)",
          "Double": "[c]double[/c] (System.Double)",
          "Decimal": "[c]decimal[/c] (System.Decimal)",
          "DateTime": "[c]System.DateTime[/c]",
          "String": "[c]string[/c] (System.String)",
          "Void": "[c]void[/c] (System.Void)",
          "Type": "[c]System.Type[/c]",
          "Array": "[c]System.Array[/c]",
          "Attribute": "[c]System.Attribute[/c]",
          "ValueType": "[c]System.ValueType[/c]",
          "Enum": "[c]System.Enum[/c]",
          "Delegate": "[c]System.Delegate[/c]",
          "MulticastDelegate": "[c]System.MulticastDelegate[/c]",
          "Exception": "[c]System.Exception[/c]",
          "IntPtr": "[c]System.IntPtr[/c]",
          "UIntPtr": "[c]System.UIntPtr[/c]",
          "IEnumerable": "[c]System.Collections.IEnumerable[/c]",
          "IEnumerator": "[c]System.Collections.IEnumerator[/c]",
          "IEnumerableOfT": "[c]System.Collections.Generic.IEnumerable{T}[/c]",
          "IEnumeratorOfT": "[c]System.Collections.Generic.IEnumerator{T}[/c]",
          "ICollection": "[c]System.Collections.Generic.ICollection[/c]",
          "ICollectionOfT": "[c]System.Collections.Generic.ICollection{T}[/c]",
          "IList": "[c]System.Collections.Generic.IList[/c]",
          "IListOfT": "[c]System.Collections.Generic.IList{T}[/c]",
          "IReadOnlyCollectionOfT": "[c]System.Collections.Generic.IReadOnlyCollection{T}[/c]",
          "IReadOnlyListOfT": "[c]System.Collections.Generic.IReadOnlyList{T}[/c]",
          "Task": "[c]System.Threading.Tasks.Task[/c]",
          "TaskOfT": "[c]System.Threading.Tasks.Task{T}[/c]",
          "ValueTask": "[c]System.Threading.Tasks.ValueTask[/c]",
          "ValueTaskOfT": "[c]System.Threading.Tasks.ValueTask{T}[/c]",
          "NullableOfT": "[c]System.Nullable{T}[/c]",
          "IDisposable": "[c]System.IDisposable[/c]",
          "IAsyncDisposable": "[c]System.IAsyncDisposable[/c]",
          "INotifyCompletion": "[c]System.Runtime.CompilerServices.INotifyCompletion[/c]",
          "ICriticalNotifyCompletion": "[c]System.Runtime.CompilerServices.ICriticalNotifyCompletion[/c]",
          "TypedReference": "[c]System.TypedReference[/c]",
          "IFormattable": "[c]System.IFormattable[/c]",
          "FormattableString": "[c]System.FormattableString[/c]",
          "DefaultInterpolatedStringHandler": "[c]System.Runtime.CompilerServices.DefaultInterpolatedStringHandler[/c]",
          "SpanOfT": "[c]System.Span{T}[/c]",
          "ReadOnlySpanOfT": "[c]System.ReadOnlySpan{T}[/c]",
          "MemoryOfT": "[c]System.Memory{T}[/c]",
          "Unsafe": "[c]System.Runtime.CompilerServices.Unsafe[/c]",
          "IAsyncEnumerableOfT": "[c]System.Collections.Generic.IAsyncEnumerable{T}[/c]",
          "IAsyncEnumeratorOfT": "[c]System.Collections.Generic.IAsyncEnumerator{T}[/c]",
          "Index": "[c]System.Index[/c]",
          "Range": "[c]System.Range[/c]"
        }
      },
      "KnownTypeReference": {
        "Body": "class KnownTypeReference {\n    \u002BIEnumerable\u2770KnownTypeReference\u2771 AllKnownTypes$\n    \u002Bstring Namespace\n    \u002Bstring Name\n    \u002Bint TypeParameterCount\n    \u002BGet(KnownTypeCode typeCode)$ KnownTypeReference\n    \u002BResolve(ITypeResolveContext context) IType\n    \u002BToString() string\n    \u002BGetCSharpNameByTypeCode(KnownTypeCode knownTypeCode)$ string\n    ~int KnownTypeCodeCount$\n    -KnownTypeReference[] knownTypeReferences$\n    ~KnownTypeCode baseType\n    ~TypeKind typeKind\n}",
        "Interfaces": {
          "ITypeReference": [
            null
          ]
        },
        "Inherited": {},
        "XmlDocs": {
          "": "Contains well-known type references.",
          "Get": "Gets the known type reference for the specified type code.\r\nReturns null for KnownTypeCode.None.",
          "GetCSharpNameByTypeCode": "Gets the C# primitive type name from the known type code.\r\nReturns null if there is no primitive name for the specified type."
        },
        "HasOne": {
          "KnownTypeCode": "KnownTypeCode",
          "TypeName": "TopLevelTypeName"
        }
      },
      "LifetimeAnnotation": {
        "Body": "class LifetimeAnnotation {\n    \u002Bbool ScopedRef\n    \u002Bbool RefScoped\n    \u002Bbool ValueScoped\n}",
        "BaseType": {
          "System_ValueType": null
        },
        "Inherited": {
          "System_ValueType": {
            "FlatMembers": "LifetimeAnnotation : -CanCompareBits(object obj)$ bool\nLifetimeAnnotation : -FastEqualsCheck(object a, object b)$ bool\nLifetimeAnnotation : ~GetHashCodeOfPtr(IntPtr ptr)$ int"
          }
        },
        "XmlDocs": {
          "ScopedRef": "C# 11 scoped annotation: \u0022scoped ref\u0022 (ScopedRefAttribute)"
        }
      },
      "MetadataModule": {
        "Body": "class MetadataModule {\n    \u002BMetadataFile MetadataFile\n    \u002Bbool IsMainModule\n    \u002Bstring AssemblyName\n    \u002BVersion AssemblyVersion\n    \u002Bstring FullAssemblyName\n    -string ICSharpCode.Decompiler.TypeSystem.ISymbol.Name\n    ~bool IncludeInternalMembers\n    ~GetString(StringHandle name) string\n    \u002BGetTypeDefinition(TopLevelTypeName topLevelTypeName) ITypeDefinition\n    \u002BInternalsVisibleTo(IModule module) bool\n    -GetInternalsVisibleTo() string[]\n    -GetShortName(string fullAssemblyName)$ string\n    \u002BGetDefinition(TypeDefinitionHandle handle) ITypeDefinition\n    \u002BGetDefinition(FieldDefinitionHandle handle) IField\n    \u002BGetDefinition(MethodDefinitionHandle handle) IMethod\n    \u002BGetDefinition(PropertyDefinitionHandle handle) IProperty\n    \u002BGetDefinition(EventDefinitionHandle handle) IEvent\n    -HandleOutOfRange(EntityHandle handle) void\n    \u002BResolveModule(AssemblyReferenceHandle handle) IModule\n    -ResolveModuleUncached(AssemblyReferenceHandle handle) IModule\n    \u002BResolveModule(ModuleReferenceHandle handle) IModule\n    \u002BGetDeclaringModule(TypeReferenceHandle handle) IModule\n    \u002BResolveType(EntityHandle typeRefDefSpec, GenericContext context, CustomAttributeHandleCollection? typeAttributes, Nullability nullableContext) IType\n    \u002BResolveType(EntityHandle typeRefDefSpec, GenericContext context, TypeSystemOptions customOptions, CustomAttributeHandleCollection? typeAttributes, Nullability nullableContext) IType\n    -ResolveDeclaringType(EntityHandle declaringTypeReference, GenericContext context) IType\n    -IntroduceTupleTypes(IType ty) IType\n    \u002BResolveMethod(EntityHandle methodReference, GenericContext context) IMethod\n    -ResolveMethodDefinition(MethodDefinitionHandle methodDefHandle, bool expandVarArgs) IMethod\n    -ResolveMethodSpecification(MethodSpecificationHandle methodSpecHandle, GenericContext context, bool expandVarArgs) IMethod\n    -ResolveMethodReference(MemberReferenceHandle memberRefHandle, GenericContext context, IReadOnlyList\u2770IType\u2771 methodTypeArguments, bool expandVarArgs) IMethod\n    -CompareTypes(IType a, IType b)$ bool\n    -CompareSignatures(IReadOnlyList\u2770IParameter\u2771 parameters, ImmutableArray\u2770IType\u2771 parameterTypes)$ bool\n    -CreateFakeMethod(IType declaringType, string name, MethodSignature\u2770IType\u2771 signature) IMethod\n    -GuessFakeMethodAccessor(IType declaringType, string name, MethodSignature\u2770IType\u2771 signature, FakeMethod m, List\u2770IParameter\u2771 parameters) void\n    \u002BResolveEntity(EntityHandle entityHandle, GenericContext context) IEntity\n    -ResolveFieldReference(MemberReferenceHandle memberReferenceHandle, GenericContext context) IField\n    \u002BDecodeMethodSignature(StandaloneSignatureHandle handle, GenericContext genericContext) ValueTuple\n    \u002BDecodeLocalSignature(StandaloneSignatureHandle handle, GenericContext genericContext) ImmutableArray\u2770IType\u2771\n    \u002BGetAssemblyAttributes() IEnumerable\u2770IAttribute\u2771\n    \u002BGetModuleAttributes() IEnumerable\u2770IAttribute\u2771\n    -AddTypeForwarderAttributes(\u0026AttributeListBuilder b) void\n    -ResolveForwardedType(ExportedType forwarder) IType\n    ~GetAttributeType(KnownAttribute attr) IType\n    ~MakeAttribute(KnownAttribute type) IAttribute\n    ~IsVisible(FieldAttributes att) bool\n    ~IsVisible(MethodAttributes att) bool\n    -FindMinimumAccessibilityForNRT(MetadataReader metadata, CustomAttributeHandleCollection customAttributes)$ Accessibility\n    ~ShouldDecodeNullableAttributes(IEntity entity) bool\n    ~OptionsForEntity(IEntity entity) TypeSystemOptions\n    ~MetadataReader metadata\n    -TypeSystemOptions options\n    ~TypeProvider TypeProvider\n    ~Nullability NullableContext\n    -MetadataNamespace rootNamespace\n    -MetadataTypeDefinition[] typeDefs\n    -MetadataField[] fieldDefs\n    -MetadataMethod[] methodDefs\n    -MetadataProperty[] propertyDefs\n    -MetadataEvent[] eventDefs\n    -IModule[] referencedAssemblies\n    -string[] internalsVisibleTo\n    -NormalizeTypeVisitor normalizeTypeVisitor$\n    -IType[] knownAttributeTypes\n    -IAttribute[] knownAttributes\n    -Accessibility minAccessibilityForNRT\n}",
        "Interfaces": {
          "IModule": [
            null
          ],
          "ISymbol": [
            null
          ],
          "ICompilationProvider": [
            null
          ]
        },
        "Inherited": {},
        "XmlDocs": {
          "": "Type system implementation for Metadata.PEFile.",
          "knownAttributeTypes": "Cache for parameterless known attribute types.",
          "knownAttributes": "Cache for parameterless known attributes.",
          "TypeDefinitions": "Gets all types in the assembly, including nested types.",
          "ResolveMethodReference": "Resolves a method reference.\r\n\r\n[remarks]\r\nClass type arguments are provided by the declaring type stored in the memberRef.\r\nMethod type arguments are provided by the caller.\r\n[/remarks]",
          "CreateFakeMethod": "Create a dummy IMethod from the specified MethodReference",
          "ResolveEntity": "Resolves a symbol.\r\n\r\n[remarks]\r\n* Types are resolved to their definition, as IType does not implement ISymbol.\r\n* types without definition will resolve to [c]null[/c]\r\n* use ResolveType() to properly resolve types\r\n* When resolving methods, varargs signatures are not expanded.\r\n* use ResolveMethod() instead to get an IMethod instance suitable for call-sites\r\n* May return specialized members, where generics are involved.\r\n* Other types of handles that don\u0027t correspond to TS entities, will return [c]null[/c].\r\n[/remarks]",
          "GetAssemblyAttributes": "Gets the list of all assembly attributes in the project.",
          "GetModuleAttributes": "Gets the list of all module attributes in the project.",
          "MakeAttribute": "Construct a builtin attribute."
        },
        "HasOne": {
          "Compilation": "ICompilation",
          "TypeSystemOptions": "TypeSystemOptions",
          "ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind": "SymbolKind",
          "RootNamespace": "INamespace"
        },
        "HasMany": {
          "TopLevelTypeDefinitions": "ITypeDefinition",
          "TypeDefinitions": "ITypeDefinition"
        }
      },
      "NormalizeTypeVisitor": {
        "Body": "class NormalizeTypeVisitor {\n    \u002BEquivalentTypes(IType a, IType b) bool\n    \u002BVisitTypeParameter(ITypeParameter type) IType\n    \u002BVisitTypeDefinition(ITypeDefinition type) IType\n    \u002BVisitTupleType(TupleType type) IType\n    \u002BVisitNullabilityAnnotatedType(NullabilityAnnotatedType type) IType\n    \u002BVisitArrayType(ArrayType type) IType\n    \u002BVisitModOpt(ModifiedType type) IType\n    \u002BVisitModReq(ModifiedType type) IType\n    ~NormalizeTypeVisitor TypeErasure$\n    ~NormalizeTypeVisitor IgnoreNullabilityAndTuples$\n    ~NormalizeTypeVisitor IgnoreNullability$\n    \u002Bbool RemoveModOpt\n    \u002Bbool RemoveModReq\n    \u002Bbool ReplaceClassTypeParametersWithDummy\n    \u002Bbool ReplaceMethodTypeParametersWithDummy\n    \u002Bbool DynamicAndObject\n    \u002Bbool IntPtrToNInt\n    \u002Bbool TupleToUnderlyingType\n    \u002Bbool RemoveNullability\n}",
        "BaseType": {
          "TypeVisitor": null
        },
        "Inherited": {
          "TypeVisitor": {
            "FlatMembers": "NormalizeTypeVisitor : \u002BVisitTypeDefinition(ITypeDefinition type) IType\nNormalizeTypeVisitor : \u002BVisitTypeParameter(ITypeParameter type) IType\nNormalizeTypeVisitor : \u002BVisitParameterizedType(ParameterizedType type) IType\nNormalizeTypeVisitor : \u002BVisitArrayType(ArrayType type) IType\nNormalizeTypeVisitor : \u002BVisitPointerType(PointerType type) IType\nNormalizeTypeVisitor : \u002BVisitByReferenceType(ByReferenceType type) IType\nNormalizeTypeVisitor : \u002BVisitTupleType(TupleType type) IType\nNormalizeTypeVisitor : \u002BVisitOtherType(IType type) IType\nNormalizeTypeVisitor : \u002BVisitModReq(ModifiedType type) IType\nNormalizeTypeVisitor : \u002BVisitModOpt(ModifiedType type) IType\nNormalizeTypeVisitor : \u002BVisitNullabilityAnnotatedType(NullabilityAnnotatedType type) IType\nNormalizeTypeVisitor : \u002BVisitFunctionPointerType(FunctionPointerType type) IType"
          }
        },
        "XmlDocs": {
          "TypeErasure": "NormalizeTypeVisitor that does not normalize type parameters,\r\nbut performs type erasure (object-\u0026gt;dynamic; tuple-\u0026gt;underlying type)."
        }
      },
      "Nullability": {
        "Body": "class Nullability {\n    \u003C\u003CEnumeration\u003E\u003E\n    Oblivious\n    NotNullable\n    Nullable\n}"
      },
      "NullableType": {
        "Body": "class NullableType {\n    \u002BIsNullable(IType type)$ bool\n    \u002BIsNonNullableValueType(IType type)$ bool\n    \u002BGetUnderlyingType(IType type)$ IType\n    \u002BCreate(ICompilation compilation, IType elementType)$ IType\n    \u002BCreate(ITypeReference elementType)$ ParameterizedTypeReference\n    \u003C\u003CService\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Static helper methods for working with nullable types.",
          "IsNullable": "Gets whether the specified type is a nullable type.",
          "GetUnderlyingType": "Returns the element type, if [type] is a nullable type.\r\nOtherwise, returns the type itself.",
          "Create": "Creates a nullable type reference."
        }
      },
      "ParameterListComparer": {
        "Body": "class ParameterListComparer {\n    \u002BWithOptions(bool includeModifiers)$ ParameterListComparer\n    \u002BEquals(IReadOnlyList\u2770IParameter\u2771 x, IReadOnlyList\u2770IParameter\u2771 y) bool\n    \u002BGetHashCode(IReadOnlyList\u2770IParameter\u2771 obj) int\n    \u002BParameterListComparer Instance$\n    -NormalizeTypeVisitor normalizationVisitor$\n    -bool includeModifiers\n}",
        "Interfaces": {
          "System_Collections_Generic_IEqualityComparer_T": [
            "IEqualityComparer\u2770IReadOnlyList\u2770IParameter\u2771\u2771"
          ]
        },
        "Inherited": {},
        "XmlDocs": {
          "": "Compares parameter lists by comparing the types of all parameters.\r\n\r\n[remarks]\r\n\u0027ref int\u0027 and \u0027out int\u0027 are considered to be equal - unless [ICSharpCode.Decompiler.TypeSystem.ParameterListComparer.includeModifiers] is set to true.\r\n\u0027object\u0027 and \u0027dynamic\u0027 are also equal.\r\nFor generic methods, \u0022Method{T}(T a)\u0022 and \u0022Method{S}(S b)\u0022 are considered equal.\r\nHowever, \u0022Method(T a)\u0022 and \u0022Method(S b)\u0022 are not considered equal when the type parameters T and S belong to classes.\r\n[/remarks]"
        }
      },
      "ParameterizedType": {
        "Body": "class ParameterizedType {\n    \u002Bbool? IsReferenceType\n    \u002Bbool IsByRefLike\n    \u002Bint TypeParameterCount\n    \u002Bstring FullName\n    \u002Bstring Name\n    \u002Bstring Namespace\n    \u002Bstring ReflectionName\n    \u002BChangeNullability(Nullability nullability) IType\n    \u002BToString() string\n    \u002BGetTypeArgument(int index) IType\n    \u002BGetDefinition() ITypeDefinition\n    \u002BGetDefinitionOrUnknown() ITypeDefinitionOrUnknown\n    \u002BGetSubstitution() TypeParameterSubstitution\n    \u002BGetSubstitution(IReadOnlyList\u2770IType\u2771 methodTypeArguments) TypeParameterSubstitution\n    \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\n    \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\n    \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options) IEnumerable\u2770IProperty\u2771\n    \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options) IEnumerable\u2770IField\u2771\n    \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options) IEnumerable\u2770IEvent\u2771\n    \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMember\u2771\n    \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BEquals(object obj) bool\n    \u002BEquals(IType other) bool\n    \u002BGetHashCode() int\n    \u002BAcceptVisitor(TypeVisitor visitor) IType\n    \u002BVisitChildren(TypeVisitor visitor) IType\n    -IType[] typeArguments\n}",
        "Interfaces": {
          "IType": [
            null
          ],
          "INamedElement": [
            null
          ],
          "System_IEquatable_T": [
            "IEquatable\u2770IType\u2771"
          ]
        },
        "Inherited": {},
        "XmlDocs": {
          "": "ParameterizedType represents an instance of a generic type.\r\nExample: List\u0026lt;string\u0026gt;\r\n\r\n[remarks]\r\nWhen getting the members, this type modifies the lists so that\r\ntype parameters in the signatures of the members are replaced with\r\nthe type arguments.\r\n[/remarks]",
          "GetTypeArgument": "Same as \u0027parameterizedType.TypeArguments[index]\u0027.",
          "GetDefinition": "Gets the definition of the generic type.\r\nFor [c]ParameterizedType[/c], this method never returns null.",
          "GetSubstitution": "Gets a type visitor that performs the substitution of class type parameters with the type arguments\r\nof this parameterized type,\r\nand also substitutes method type parameters with the specified method type arguments."
        },
        "HasOne": {
          "Kind": "TypeKind",
          "GenericType": "IType",
          "Nullability": "Nullability",
          "DeclaringType": "IType"
        },
        "HasMany": {
          "TypeArguments": "IType",
          "TypeParameters": "ITypeParameter",
          "DirectBaseTypes": "IType"
        }
      },
      "ParameterizedTypeReference": {
        "Body": "class ParameterizedTypeReference {\n    \u002BResolve(ITypeResolveContext context) IType\n    \u002BToString() string\n    -ISupportsInterning.GetHashCodeForInterning() int\n    -ISupportsInterning.EqualsForInterning(ISupportsInterning other) bool\n    -ITypeReference[] typeArguments\n}",
        "Interfaces": {
          "ITypeReference": [
            null
          ],
          "ISupportsInterning": [
            null
          ]
        },
        "Inherited": {},
        "XmlDocs": {
          "": "ParameterizedTypeReference is a reference to generic class that specifies the type parameters.\r\nExample: List\u0026lt;string\u0026gt;"
        },
        "HasOne": {
          "GenericType": "ITypeReference"
        },
        "HasMany": {
          "TypeArguments": "ITypeReference"
        }
      },
      "PointerType": {
        "Body": "class PointerType {\n    \u002Bstring NameSuffix\n    \u002Bbool? IsReferenceType\n    \u002BGetHashCode() int\n    \u002BEquals(IType other) bool\n    \u002BAcceptVisitor(TypeVisitor visitor) IType\n    \u002BVisitChildren(TypeVisitor visitor) IType\n}",
        "BaseType": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_TypeWithElementType": null
        },
        "Inherited": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_AbstractType": {
            "FlatMembers": "PointerType : \u002Bstring FullName\nPointerType : \u002Bstring Name*\nPointerType : \u002Bstring Namespace\nPointerType : \u002Bstring ReflectionName\nPointerType : \u002Bbool? IsReferenceType*\nPointerType : \u002Bbool IsByRefLike\nPointerType : \u002Bint TypeParameterCount\nPointerType : \u002BChangeNullability(Nullability nullability) IType\nPointerType : \u002BGetDefinition() ITypeDefinition\nPointerType : \u002BGetDefinitionOrUnknown() ITypeDefinitionOrUnknown\nPointerType : \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nPointerType : \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nPointerType : \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nPointerType : \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nPointerType : \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nPointerType : \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options) IEnumerable\u2770IProperty\u2771\nPointerType : \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options) IEnumerable\u2770IField\u2771\nPointerType : \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options) IEnumerable\u2770IEvent\u2771\nPointerType : \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMember\u2771\nPointerType : \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nPointerType : \u002BGetSubstitution() TypeParameterSubstitution\nPointerType : \u002BGetSubstitution(IReadOnlyList\u2770IType\u2771 methodTypeArguments) TypeParameterSubstitution\nPointerType : \u002BEquals(IType other) bool\nPointerType : \u002BAcceptVisitor(TypeVisitor visitor) IType\nPointerType : \u002BVisitChildren(TypeVisitor visitor) IType",
            "HasOne": {
              "Nullability": "Nullability",
              "Kind": "TypeKind",
              "DeclaringType": "IType"
            },
            "HasMany": {
              "TypeParameters": "ITypeParameter",
              "TypeArguments": "IType",
              "DirectBaseTypes": "IType"
            }
          },
          "ICSharpCode_Decompiler_TypeSystem_Implementation_TypeWithElementType": {
            "FlatMembers": "PointerType : \u002Bstring Name\nPointerType : \u002Bstring Namespace\nPointerType : \u002Bstring FullName\nPointerType : \u002Bstring ReflectionName\nPointerType : \u002Bstring NameSuffix*\nPointerType : \u002BToString() string\nPointerType : \u002BVisitChildren(TypeVisitor visitor)* IType",
            "HasOne": {
              "ElementType": "IType"
            }
          }
        },
        "HasOne": {
          "Kind": "TypeKind"
        }
      },
      "PointerTypeReference": {
        "Body": "class PointerTypeReference {\n    \u002BResolve(ITypeResolveContext context) IType\n    \u002BToString() string\n    -ISupportsInterning.GetHashCodeForInterning() int\n    -ISupportsInterning.EqualsForInterning(ISupportsInterning other) bool\n}",
        "Interfaces": {
          "ITypeReference": [
            null
          ],
          "ISupportsInterning": [
            null
          ]
        },
        "Inherited": {},
        "HasOne": {
          "ElementType": "ITypeReference"
        }
      },
      "ReferenceKind": {
        "Body": "class ReferenceKind {\n    \u003C\u003CEnumeration\u003E\u003E\n    None\n    Out\n    Ref\n    In\n    RefReadOnly\n}",
        "XmlDocs": {
          "": "[remarks]\r\nShould match order in [ICSharpCode.Decompiler.CSharp.Syntax.FieldDirection].\r\n[/remarks]"
        }
      },
      "ReferenceResolvingException": {
        "Body": "class ReferenceResolvingException {\n    \n}",
        "BaseType": {
          "System_Exception": null
        },
        "Inherited": {
          "System_Exception": {
            "FlatMembers": "ReferenceResolvingException : \u002BMethodBase TargetSite\nReferenceResolvingException : \u002Bstring StackTrace\nReferenceResolvingException : -string SerializationRemoteStackTraceString\nReferenceResolvingException : -object SerializationWatsonBuckets\nReferenceResolvingException : -string SerializationStackTraceString\nReferenceResolvingException : \u002Bstring Message\nReferenceResolvingException : \u002BIDictionary Data\nReferenceResolvingException : \u002BException InnerException\nReferenceResolvingException : \u002Bstring HelpLink\nReferenceResolvingException : \u002Bstring Source\nReferenceResolvingException : \u002Bint HResult\nReferenceResolvingException : -CreateDataContainer() IDictionary\nReferenceResolvingException : -IsImmutableAgileException(Exception e)$ bool\nReferenceResolvingException : ~AddExceptionDataForRestrictedErrorInfo(string restrictedError, string restrictedErrorReference, string restrictedCapabilitySid, object restrictedErrorObject, bool hasrestrictedLanguageErrorObject) void\nReferenceResolvingException : ~TryGetRestrictedLanguageErrorObject(\u0026object restrictedErrorObject) bool\nReferenceResolvingException : -GetMethodFromStackTrace(object stackTrace)$ IRuntimeMethodInfo\nReferenceResolvingException : -GetExceptionMethodFromStackTrace() MethodBase\nReferenceResolvingException : -GetStackTrace(Exception e)$ string\nReferenceResolvingException : -CreateSourceName() string\nReferenceResolvingException : -OnDeserialized(StreamingContext context) void\nReferenceResolvingException : ~InternalPreserveStackTrace() void\nReferenceResolvingException : -PrepareForForeignExceptionRaise()$ void\nReferenceResolvingException : -GetStackTracesDeepCopy(Exception exception, \u0026object currentStackTrace, \u0026object dynamicMethodArray)$ void\nReferenceResolvingException : ~SaveStackTracesFromDeepCopy(Exception exception, object currentStackTrace, object dynamicMethodArray)$ void\nReferenceResolvingException : -CopyStackTrace(object currentStackTrace)$ object\nReferenceResolvingException : -CopyDynamicMethods(object currentDynamicMethods)$ object\nReferenceResolvingException : ~GetExceptionCount()$ uint\nReferenceResolvingException : ~DeepCopyStackTrace(object currentStackTrace) object\nReferenceResolvingException : ~DeepCopyDynamicMethods(object currentDynamicMethods) object\nReferenceResolvingException : ~RestoreDispatchState(\u0026Exception\u002BDispatchState dispatchState) void\nReferenceResolvingException : ~GetMessageFromNativeResources(Exception\u002BExceptionMessageKind kind)$ string\nReferenceResolvingException : -GetMessageFromNativeResources(Exception\u002BExceptionMessageKind kind, StringHandleOnStack retMesg)$ void\nReferenceResolvingException : ~CaptureDispatchState() Exception\u002BDispatchState\nReferenceResolvingException : -GetClassName() string\nReferenceResolvingException : \u002BGetBaseException() Exception\nReferenceResolvingException : \u002BGetObjectData(SerializationInfo info, StreamingContext context) void\nReferenceResolvingException : \u002BGetType() Type\nReferenceResolvingException : -RestoreRemoteStackTrace(SerializationInfo info, StreamingContext context) void\nReferenceResolvingException : -object s_DispatchStateLock$\nReferenceResolvingException : -MethodBase _exceptionMethod\nReferenceResolvingException : ~string _message\nReferenceResolvingException : -IDictionary _data\nReferenceResolvingException : -Exception _innerException\nReferenceResolvingException : -string _helpURL\nReferenceResolvingException : -object _stackTrace\nReferenceResolvingException : -object _watsonBuckets\nReferenceResolvingException : -string _stackTraceString\nReferenceResolvingException : -string _remoteStackTraceString\nReferenceResolvingException : -object _dynamicMethods\nReferenceResolvingException : -string _source\nReferenceResolvingException : -UIntPtr _ipForWatsonBuckets\nReferenceResolvingException : -IntPtr _xptrs\nReferenceResolvingException : -int _xcode\nReferenceResolvingException : -int _COMPlusExceptionCode$\nReferenceResolvingException : ~string InnerExceptionPrefix$"
          }
        },
        "XmlDocs": {
          "": "Represents an error while resolving a reference to a type or a member."
        }
      },
      "ReflectionHelper": {
        "Body": "class ReflectionHelper {\n    \u002BFindType(ICompilation compilation, Type type)$ IType\n    \u002BFindType(ICompilation compilation, StackType stackType, Sign sign)$ IType\n    \u002BToTypeReference(Type type)$ ITypeReference\n    \u002BSplitTypeParameterCountFromReflectionName(string reflectionName)$ string\n    \u002BSplitTypeParameterCountFromReflectionName(string reflectionName, \u0026int typeParameterCount)$ string\n    \u002BFindType(ICompilation compilation, TypeCode typeCode)$ IType\n    \u002BToTypeReference(TypeCode typeCode)$ ITypeReference\n    \u002BGetTypeCode(IType type)$ TypeCode\n    \u002BParseReflectionName(string reflectionTypeName)$ ITypeReference\n    -IsReflectionNameSpecialCharacter(char c)$ bool\n    -ParseReflectionName(string reflectionTypeName, \u0026int pos, bool local)$ ITypeReference\n    -CreateGetClassTypeReference(string assemblyName, string typeName, int tpc)$ ITypeReference\n    -SkipAheadAndReadAssemblyName(string reflectionTypeName, int pos)$ string\n    -ReadTypeName(string reflectionTypeName, \u0026int pos, \u0026int tpc)$ string\n    ~ReadTypeParameterCount(string reflectionTypeName, \u0026int pos)$ int\n    \u003C\u003CService\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Static helper methods for reflection names.",
          "FindType": "Retrieves a built-in type using the specified type code.",
          "ToTypeReference": "Creates a reference to the specified type.\r\n\r\n[param name=\u0022typeCode\u0022]The type to be converted.[/param]\r\n[returns]Returns the type reference.[/returns]",
          "SplitTypeParameterCountFromReflectionName": "Removes the \u0060 with type parameter count from the reflection name.\r\n\r\n[remarks]Do not use this method with the full name of inner classes.[/remarks]",
          "GetTypeCode": "Gets the type code for the specified type, or TypeCode.Empty if none of the other type codes match.",
          "ParseReflectionName": "Parses the reflection name starting at pos.\r\nIf local is true, only parses local type names, not assembly qualified type names."
        }
      },
      "Dynamic": {
        "Name": "ReflectionHelper\u002BDynamic",
        "Body": "class Dynamic {\n    \n}",
        "Inherited": {},
        "XmlDocs": {
          "": "A reflection class used to represent [c]dynamic[/c]."
        }
      },
      "NInt": {
        "Name": "ReflectionHelper\u002BNInt",
        "Body": "class NInt {\n    \n}",
        "Inherited": {},
        "XmlDocs": {
          "": "A reflection class used to represent [c]nint[/c]."
        }
      },
      "NUInt": {
        "Name": "ReflectionHelper\u002BNUInt",
        "Body": "class NUInt {\n    \n}",
        "Inherited": {},
        "XmlDocs": {
          "": "A reflection class used to represent [c]nuint[/c]."
        }
      },
      "Null": {
        "Name": "ReflectionHelper\u002BNull",
        "Body": "class Null {\n    \n}",
        "Inherited": {},
        "XmlDocs": {
          "": "A reflection class used to represent [c]null[/c]."
        }
      },
      "UnboundTypeArgument": {
        "Name": "ReflectionHelper\u002BUnboundTypeArgument",
        "Body": "class UnboundTypeArgument {\n    \n}",
        "Inherited": {},
        "XmlDocs": {
          "": "A reflection class used to represent an unbound type argument."
        }
      },
      "ReflectionNameParseException": {
        "Body": "class ReflectionNameParseException {\n    \u002Bint Position\n    \u002BGetObjectData(SerializationInfo info, StreamingContext context) void\n}",
        "BaseType": {
          "System_Exception": null
        },
        "Inherited": {
          "System_Exception": {
            "FlatMembers": "ReflectionNameParseException : \u002BMethodBase TargetSite\nReflectionNameParseException : \u002Bstring StackTrace\nReflectionNameParseException : -string SerializationRemoteStackTraceString\nReflectionNameParseException : -object SerializationWatsonBuckets\nReflectionNameParseException : -string SerializationStackTraceString\nReflectionNameParseException : \u002Bstring Message\nReflectionNameParseException : \u002BIDictionary Data\nReflectionNameParseException : \u002BException InnerException\nReflectionNameParseException : \u002Bstring HelpLink\nReflectionNameParseException : \u002Bstring Source\nReflectionNameParseException : \u002Bint HResult\nReflectionNameParseException : -CreateDataContainer() IDictionary\nReflectionNameParseException : -IsImmutableAgileException(Exception e)$ bool\nReflectionNameParseException : ~AddExceptionDataForRestrictedErrorInfo(string restrictedError, string restrictedErrorReference, string restrictedCapabilitySid, object restrictedErrorObject, bool hasrestrictedLanguageErrorObject) void\nReflectionNameParseException : ~TryGetRestrictedLanguageErrorObject(\u0026object restrictedErrorObject) bool\nReflectionNameParseException : -GetMethodFromStackTrace(object stackTrace)$ IRuntimeMethodInfo\nReflectionNameParseException : -GetExceptionMethodFromStackTrace() MethodBase\nReflectionNameParseException : -GetStackTrace(Exception e)$ string\nReflectionNameParseException : -CreateSourceName() string\nReflectionNameParseException : -OnDeserialized(StreamingContext context) void\nReflectionNameParseException : ~InternalPreserveStackTrace() void\nReflectionNameParseException : -PrepareForForeignExceptionRaise()$ void\nReflectionNameParseException : -GetStackTracesDeepCopy(Exception exception, \u0026object currentStackTrace, \u0026object dynamicMethodArray)$ void\nReflectionNameParseException : ~SaveStackTracesFromDeepCopy(Exception exception, object currentStackTrace, object dynamicMethodArray)$ void\nReflectionNameParseException : -CopyStackTrace(object currentStackTrace)$ object\nReflectionNameParseException : -CopyDynamicMethods(object currentDynamicMethods)$ object\nReflectionNameParseException : ~GetExceptionCount()$ uint\nReflectionNameParseException : ~DeepCopyStackTrace(object currentStackTrace) object\nReflectionNameParseException : ~DeepCopyDynamicMethods(object currentDynamicMethods) object\nReflectionNameParseException : ~RestoreDispatchState(\u0026Exception\u002BDispatchState dispatchState) void\nReflectionNameParseException : ~GetMessageFromNativeResources(Exception\u002BExceptionMessageKind kind)$ string\nReflectionNameParseException : -GetMessageFromNativeResources(Exception\u002BExceptionMessageKind kind, StringHandleOnStack retMesg)$ void\nReflectionNameParseException : ~CaptureDispatchState() Exception\u002BDispatchState\nReflectionNameParseException : -GetClassName() string\nReflectionNameParseException : \u002BGetBaseException() Exception\nReflectionNameParseException : \u002BGetObjectData(SerializationInfo info, StreamingContext context) void\nReflectionNameParseException : \u002BGetType() Type\nReflectionNameParseException : -RestoreRemoteStackTrace(SerializationInfo info, StreamingContext context) void\nReflectionNameParseException : -object s_DispatchStateLock$\nReflectionNameParseException : -MethodBase _exceptionMethod\nReflectionNameParseException : ~string _message\nReflectionNameParseException : -IDictionary _data\nReflectionNameParseException : -Exception _innerException\nReflectionNameParseException : -string _helpURL\nReflectionNameParseException : -object _stackTrace\nReflectionNameParseException : -object _watsonBuckets\nReflectionNameParseException : -string _stackTraceString\nReflectionNameParseException : -string _remoteStackTraceString\nReflectionNameParseException : -object _dynamicMethods\nReflectionNameParseException : -string _source\nReflectionNameParseException : -UIntPtr _ipForWatsonBuckets\nReflectionNameParseException : -IntPtr _xptrs\nReflectionNameParseException : -int _xcode\nReflectionNameParseException : -int _COMPlusExceptionCode$\nReflectionNameParseException : ~string InnerExceptionPrefix$"
          }
        },
        "XmlDocs": {
          "": "Represents an error while parsing a reflection name."
        }
      },
      "Sign": {
        "Body": "class Sign {\n    \u003C\u003CEnumeration\u003E\u003E\n    None\n    Signed\n    Unsigned\n}"
      },
      "SignatureComparer": {
        "Body": "class SignatureComparer {\n    \u002BEquals(IMember x, IMember y) bool\n    \u002BGetHashCode(IMember obj) int\n    -StringComparer nameComparer\n    \u002BSignatureComparer Ordinal$\n}",
        "Interfaces": {
          "System_Collections_Generic_IEqualityComparer_T": [
            "IEqualityComparer\u2770IMember\u2771"
          ]
        },
        "Inherited": {},
        "XmlDocs": {
          "": "Compares member signatures.\r\n\r\n[remarks]\r\nThis comparer checks for equal short name, equal type parameter count, and equal parameter types (using ParameterListComparer).\r\n[/remarks]",
          "Ordinal": "Gets a signature comparer that uses an ordinal comparison for the member name."
        }
      },
      "SimpleTypeResolveContext": {
        "Body": "class SimpleTypeResolveContext {\n    \u002BWithCurrentTypeDefinition(ITypeDefinition typeDefinition) ITypeResolveContext\n    \u002BWithCurrentMember(IMember member) ITypeResolveContext\n}",
        "Interfaces": {
          "ITypeResolveContext": [
            null
          ],
          "ICompilationProvider": [
            null
          ]
        },
        "Inherited": {},
        "XmlDocs": {
          "": "Default ITypeResolveContext implementation."
        },
        "HasOne": {
          "Compilation": "ICompilation",
          "CurrentModule": "IModule",
          "CurrentTypeDefinition": "ITypeDefinition",
          "CurrentMember": "IMember"
        }
      },
      "SpecialType": {
        "Body": "class SpecialType {\n    \u002Bstring Name\n    \u002Bbool? IsReferenceType\n    -ITypeReference.Resolve(ITypeResolveContext context) IType\n    \u002BEquals(IType other) bool\n    \u002BGetHashCode() int\n    \u002BChangeNullability(Nullability nullability) IType\n    \u002BSpecialType UnknownType$\n    \u002BSpecialType NullType$\n    \u002BSpecialType NoType$\n    \u002BSpecialType Dynamic$\n    \u002BSpecialType NInt$\n    \u002BSpecialType NUInt$\n    \u002BSpecialType ArgList$\n    \u002BSpecialType UnboundTypeArgument$\n}",
        "BaseType": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_AbstractType": null
        },
        "Interfaces": {
          "ITypeReference": [
            null
          ]
        },
        "Inherited": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_AbstractType": {
            "FlatMembers": "SpecialType : \u002Bstring FullName\nSpecialType : \u002Bstring Name*\nSpecialType : \u002Bstring Namespace\nSpecialType : \u002Bstring ReflectionName\nSpecialType : \u002Bbool? IsReferenceType*\nSpecialType : \u002Bbool IsByRefLike\nSpecialType : \u002Bint TypeParameterCount\nSpecialType : \u002BChangeNullability(Nullability nullability) IType\nSpecialType : \u002BGetDefinition() ITypeDefinition\nSpecialType : \u002BGetDefinitionOrUnknown() ITypeDefinitionOrUnknown\nSpecialType : \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nSpecialType : \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nSpecialType : \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nSpecialType : \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nSpecialType : \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nSpecialType : \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options) IEnumerable\u2770IProperty\u2771\nSpecialType : \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options) IEnumerable\u2770IField\u2771\nSpecialType : \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options) IEnumerable\u2770IEvent\u2771\nSpecialType : \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMember\u2771\nSpecialType : \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nSpecialType : \u002BGetSubstitution() TypeParameterSubstitution\nSpecialType : \u002BGetSubstitution(IReadOnlyList\u2770IType\u2771 methodTypeArguments) TypeParameterSubstitution\nSpecialType : \u002BEquals(IType other) bool\nSpecialType : \u002BAcceptVisitor(TypeVisitor visitor) IType\nSpecialType : \u002BVisitChildren(TypeVisitor visitor) IType",
            "HasOne": {
              "Nullability": "Nullability",
              "Kind": "TypeKind",
              "DeclaringType": "IType"
            },
            "HasMany": {
              "TypeParameters": "ITypeParameter",
              "TypeArguments": "IType",
              "DirectBaseTypes": "IType"
            }
          }
        },
        "XmlDocs": {
          "": "Contains static implementations of special types.",
          "UnknownType": "Gets the type representing resolve errors.",
          "NullType": "The null type is used as type of the null literal. It is a reference type without any members; and it is a subtype of all reference types.",
          "NoType": "Used for expressions without type, e.g. method groups or lambdas.",
          "Dynamic": "Type representing the C# \u0027dynamic\u0027 type.",
          "NInt": "Type representing the C# 9 \u0027nint\u0027 type.",
          "NUInt": "Type representing the C# 9 \u0027nuint\u0027 type.",
          "ArgList": "Type representing the result of the C# \u0027__arglist()\u0027 expression.",
          "UnboundTypeArgument": "A type used for unbound type arguments in partially parameterized types.\r\n\r\n[ICSharpCode.Decompiler.TypeSystem.IType.GetNestedTypes(System.Predicate{ICSharpCode.Decompiler.TypeSystem.ITypeDefinition},ICSharpCode.Decompiler.TypeSystem.GetMemberOptions)]"
        },
        "HasOne": {
          "Kind": "TypeKind"
        }
      },
      "SymbolKind": {
        "Body": "class SymbolKind {\n    \u003C\u003CEnumeration\u003E\u003E\n    None\n    Module\n    TypeDefinition\n    Field\n    Property\n    Indexer\n    Event\n    Method\n    Operator\n    Constructor\n    Destructor\n    Accessor\n    Namespace\n    Variable\n    Parameter\n    TypeParameter\n    Constraint\n    ReturnType\n}",
        "XmlDocs": {
          "Module": "[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.IModule]",
          "TypeDefinition": "[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.ITypeDefinition]",
          "Field": "[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.IField]",
          "Property": "The symbol is a property, but not an indexer.\r\n\r\n[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.IProperty]",
          "Indexer": "The symbol is an indexer, not a regular property.\r\n\r\n[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.IProperty]",
          "Event": "[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.IEvent]",
          "Method": "The symbol is a method which is not an operator/constructor/destructor or accessor.\r\n\r\n[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.IMethod]",
          "Operator": "The symbol is a user-defined operator.\r\n\r\n[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.IMethod]",
          "Constructor": "[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.IMethod]",
          "Destructor": "[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.IMethod]",
          "Accessor": "The accessor method for a property getter/setter or event add/remove.\r\n\r\n[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.IMethod]",
          "Namespace": "[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.INamespace]",
          "Variable": "The symbol is a variable, but not a parameter.\r\n\r\n[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.IVariable]",
          "Parameter": "[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.IParameter]",
          "TypeParameter": "[seealso cref=\u0022T:ICSharpCode.Decompiler.TypeSystem.ITypeParameter]",
          "Constraint": "Constraint on a type parameter.",
          "ReturnType": "Return type. Not actually an ISymbol implementation; but can appear as attribut target."
        }
      },
      "TaskType": {
        "Body": "class TaskType {\n    \u002BUnpackTask(ICompilation compilation, IType type)$ IType\n    \u002BIsTask(IType type)$ bool\n    \u002BIsCustomTask(IType type, \u0026IType builderType)$ bool\n    \u002BIsNonGenericTaskType(IType task, \u0026FullTypeName builderTypeName)$ bool\n    \u002BIsGenericTaskType(IType task, \u0026FullTypeName builderTypeName)$ bool\n    \u002BCreate(ICompilation compilation, IType elementType)$ IType\n    -string ns$\n    \u003C\u003CService\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Helper class for dealing with System.Threading.Tasks.Task.",
          "UnpackTask": "Gets the T in Task\u0026lt;T\u0026gt;.\r\nReturns void for non-generic Task.\r\nAny other type is returned unmodified.",
          "IsTask": "Gets whether the specified type is Task or Task\u0026lt;T\u0026gt;.",
          "IsCustomTask": "Gets whether the specified type is a Task-like type.",
          "IsNonGenericTaskType": "Gets whether the specified type is a non-generic Task-like type.\r\n\r\n[param name=\u0022builderTypeName\u0022]Returns the full type-name of the builder type, if successful.[/param]",
          "IsGenericTaskType": "Gets whether the specified type is a generic Task-like type.\r\n\r\n[param name=\u0022builderTypeName\u0022]Returns the full type-name of the builder type, if successful.[/param]",
          "Create": "Creates a task type."
        }
      },
      "TopLevelTypeName": {
        "Body": "class TopLevelTypeName {\n    \u002Bstring Namespace\n    \u002Bstring Name\n    \u002Bint TypeParameterCount\n    \u002Bstring ReflectionName\n    \u002BToString() string\n    \u002BEquals(object obj) bool\n    \u002BEquals(TopLevelTypeName other) bool\n    \u002BGetHashCode() int\n}",
        "BaseType": {
          "System_ValueType": null
        },
        "Interfaces": {
          "System_IEquatable_T": [
            "IEquatable\u2770TopLevelTypeName\u2771"
          ]
        },
        "Inherited": {
          "System_ValueType": {
            "FlatMembers": "TopLevelTypeName : -CanCompareBits(object obj)$ bool\nTopLevelTypeName : -FastEqualsCheck(object a, object b)$ bool\nTopLevelTypeName : ~GetHashCodeOfPtr(IntPtr ptr)$ int"
          }
        },
        "XmlDocs": {
          "": "Holds the name of a top-level type.\r\nThis struct cannot refer to nested classes."
        }
      },
      "TopLevelTypeNameComparer": {
        "Body": "class TopLevelTypeNameComparer {\n    \u002BEquals(TopLevelTypeName x, TopLevelTypeName y) bool\n    \u002BGetHashCode(TopLevelTypeName obj) int\n    \u002BTopLevelTypeNameComparer Ordinal$\n    \u002BTopLevelTypeNameComparer OrdinalIgnoreCase$\n    \u002BStringComparer NameComparer\n}",
        "Interfaces": {
          "System_Collections_Generic_IEqualityComparer_T": [
            "IEqualityComparer\u2770TopLevelTypeName\u2771"
          ]
        },
        "Inherited": {}
      },
      "TupleType": {
        "Body": "class TupleType {\n    \u002Bint Cardinality\n    \u002BImmutableArray\u2770string\u2771 ElementNames\n    \u002Bbool? IsReferenceType\n    \u002Bint TypeParameterCount\n    \u002Bstring FullName\n    \u002Bstring Name\n    \u002Bstring ReflectionName\n    \u002Bstring Namespace\n    -CreateUnderlyingType(ICompilation compilation, ImmutableArray\u2770IType\u2771 elementTypes, IModule valueTupleAssembly)$ ParameterizedType\n    -FindValueTupleType(ICompilation compilation, IModule valueTupleAssembly, int tpc)$ IType\n    \u002BIsTupleCompatible(IType type, \u0026int tupleCardinality)$ bool\n    \u002BFromUnderlyingType(ICompilation compilation, IType type)$ TupleType\n    \u002BGetTupleElementTypes(IType tupleType)$ ImmutableArray\u2770IType\u2771\n    \u002BEquals(IType other) bool\n    \u002BGetHashCode() int\n    \u002BToString() string\n    \u002BAcceptVisitor(TypeVisitor visitor) IType\n    \u002BVisitChildren(TypeVisitor visitor) IType\n    \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BGetDefinition() ITypeDefinition\n    \u002BGetDefinitionOrUnknown() ITypeDefinitionOrUnknown\n    \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options) IEnumerable\u2770IEvent\u2771\n    \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options) IEnumerable\u2770IField\u2771\n    \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\n    \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\n    \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\n    \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options) IEnumerable\u2770IProperty\u2771\n    \u002Bint RestPosition$\n    -int RestIndex$\n}",
        "BaseType": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_AbstractType": null
        },
        "Interfaces": {
          "ICompilationProvider": [
            null
          ]
        },
        "Inherited": {
          "ICSharpCode_Decompiler_TypeSystem_Implementation_AbstractType": {
            "FlatMembers": "TupleType : \u002Bstring FullName\nTupleType : \u002Bstring Name*\nTupleType : \u002Bstring Namespace\nTupleType : \u002Bstring ReflectionName\nTupleType : \u002Bbool? IsReferenceType*\nTupleType : \u002Bbool IsByRefLike\nTupleType : \u002Bint TypeParameterCount\nTupleType : \u002BChangeNullability(Nullability nullability) IType\nTupleType : \u002BGetDefinition() ITypeDefinition\nTupleType : \u002BGetDefinitionOrUnknown() ITypeDefinitionOrUnknown\nTupleType : \u002BGetNestedTypes(Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nTupleType : \u002BGetNestedTypes(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770ITypeDefinition\u2771 filter, GetMemberOptions options) IEnumerable\u2770IType\u2771\nTupleType : \u002BGetMethods(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nTupleType : \u002BGetMethods(IReadOnlyList\u2770IType\u2771 typeArguments, Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nTupleType : \u002BGetConstructors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nTupleType : \u002BGetProperties(Predicate\u2770IProperty\u2771 filter, GetMemberOptions options) IEnumerable\u2770IProperty\u2771\nTupleType : \u002BGetFields(Predicate\u2770IField\u2771 filter, GetMemberOptions options) IEnumerable\u2770IField\u2771\nTupleType : \u002BGetEvents(Predicate\u2770IEvent\u2771 filter, GetMemberOptions options) IEnumerable\u2770IEvent\u2771\nTupleType : \u002BGetMembers(Predicate\u2770IMember\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMember\u2771\nTupleType : \u002BGetAccessors(Predicate\u2770IMethod\u2771 filter, GetMemberOptions options) IEnumerable\u2770IMethod\u2771\nTupleType : \u002BGetSubstitution() TypeParameterSubstitution\nTupleType : \u002BGetSubstitution(IReadOnlyList\u2770IType\u2771 methodTypeArguments) TypeParameterSubstitution\nTupleType : \u002BEquals(IType other) bool\nTupleType : \u002BAcceptVisitor(TypeVisitor visitor) IType\nTupleType : \u002BVisitChildren(TypeVisitor visitor) IType",
            "HasOne": {
              "Nullability": "Nullability",
              "Kind": "TypeKind",
              "DeclaringType": "IType"
            },
            "HasMany": {
              "TypeParameters": "ITypeParameter",
              "TypeArguments": "IType",
              "DirectBaseTypes": "IType"
            }
          }
        },
        "XmlDocs": {
          "UnderlyingType": "Gets the underlying [c]System.ValueType[/c] type.",
          "ElementTypes": "Gets the tuple elements.",
          "Cardinality": "Gets the cardinality of the tuple.",
          "ElementNames": "Gets the names of the tuple elements.",
          "IsTupleCompatible": "Gets whether the specified type is a valid underlying type for a tuple.\r\nAlso returns true for tuple types themselves.",
          "FromUnderlyingType": "Construct a tuple type (without element names) from the given underlying type.\r\nReturns null if the input is not a valid underlying type.",
          "GetTupleElementTypes": "Gets the tuple element types from a tuple type or tuple underlying type."
        },
        "HasOne": {
          "Compilation": "ICompilation",
          "UnderlyingType": "ParameterizedType",
          "Kind": "TypeKind"
        },
        "HasMany": {
          "ElementTypes": "IType",
          "TypeParameters": "ITypeParameter",
          "TypeArguments": "IType",
          "DirectBaseTypes": "IType"
        }
      },
      "TupleTypeExtensions": {
        "Body": "class TupleTypeExtensions {\n    \u002BTupleUnderlyingTypeOrSelf(IType type)$ IType\n    \u003C\u003CService\u003E\u003E\n}",
        "Inherited": {}
      },
      "TupleTypeReference": {
        "Body": "class TupleTypeReference {\n    \u002BImmutableArray\u2770string\u2771 ElementNames\n    \u002BResolve(ITypeResolveContext context) IType\n}",
        "Interfaces": {
          "ITypeReference": [
            null
          ]
        },
        "Inherited": {},
        "XmlDocs": {
          "ElementTypes": "Gets the types of the tuple elements.",
          "ElementNames": "Gets the names of the tuple elements."
        },
        "HasOne": {
          "ValueTupleAssembly": "IModuleReference"
        },
        "HasMany": {
          "ElementTypes": "ITypeReference"
        }
      },
      "TypeConstraint": {
        "Body": "class TypeConstraint {\n    \u002BIType Type\n    \u002BIReadOnlyList\u2770IAttribute\u2771 Attributes\n}",
        "BaseType": {
          "System_ValueType": null
        },
        "Inherited": {
          "System_ValueType": {
            "FlatMembers": "TypeConstraint : -CanCompareBits(object obj)$ bool\nTypeConstraint : -FastEqualsCheck(object a, object b)$ bool\nTypeConstraint : ~GetHashCodeOfPtr(IntPtr ptr)$ int"
          }
        },
        "HasOne": {
          "SymbolKind": "SymbolKind"
        }
      },
      "TypeKind": {
        "Body": "class TypeKind {\n    \u003C\u003CEnumeration\u003E\u003E\n    Other\n    Class\n    Interface\n    Struct\n    Delegate\n    Enum\n    Void\n    Unknown\n    Null\n    None\n    Dynamic\n    UnboundTypeArgument\n    TypeParameter\n    Array\n    Pointer\n    ByReference\n    Intersection\n    ArgList\n    Tuple\n    ModOpt\n    ModReq\n    NInt\n    NUInt\n    FunctionPointer\n}",
        "XmlDocs": {
          "": ".",
          "Other": "Language-specific type that is not part of NRefactory.TypeSystem itself.",
          "Class": "A [ICSharpCode.Decompiler.TypeSystem.ITypeDefinition] or [ICSharpCode.Decompiler.TypeSystem.ParameterizedType] that is a class.",
          "Interface": "A [ICSharpCode.Decompiler.TypeSystem.ITypeDefinition] or [ICSharpCode.Decompiler.TypeSystem.ParameterizedType] that is an interface.",
          "Struct": "A [ICSharpCode.Decompiler.TypeSystem.ITypeDefinition] or [ICSharpCode.Decompiler.TypeSystem.ParameterizedType] that is a struct.",
          "Delegate": "A [ICSharpCode.Decompiler.TypeSystem.ITypeDefinition] or [ICSharpCode.Decompiler.TypeSystem.ParameterizedType] that is a delegate.\r\n[remarks][c]System.Delegate[/c] itself is TypeKind.Class[/remarks]",
          "Enum": "A [ICSharpCode.Decompiler.TypeSystem.ITypeDefinition] that is an enum.\r\n[remarks][c]System.Enum[/c] itself is TypeKind.Class[/remarks]",
          "Void": "The [c]System.Void[/c] type.\r\n[ICSharpCode.Decompiler.TypeSystem.KnownTypeCode.Void]",
          "Unknown": "Type used for invalid expressions and for types whose definition could not be found.\r\n[ICSharpCode.Decompiler.TypeSystem.SpecialType.UnknownType]",
          "Null": "The type of the null literal.\r\n[ICSharpCode.Decompiler.TypeSystem.SpecialType.NullType]",
          "None": "The type of expressions without type (except for null literals, which have [c]TypeKind.Null[/c]).\r\n[ICSharpCode.Decompiler.TypeSystem.SpecialType.NoType]",
          "Dynamic": "Type representing the C# \u0027dynamic\u0027 type.\r\n[ICSharpCode.Decompiler.TypeSystem.SpecialType.Dynamic]",
          "UnboundTypeArgument": "Represents missing type arguments in partially parameterized types.\r\n[ICSharpCode.Decompiler.TypeSystem.SpecialType.UnboundTypeArgument]\r\n[ICSharpCode.Decompiler.TypeSystem.IType\u0022]IType.GetNestedTypes(Predicate{ITypeDefinition}, GetMemberOptions)[/see]",
          "TypeParameter": "The type is a type parameter.\r\n[ICSharpCode.Decompiler.TypeSystem.ITypeParameter]",
          "Array": "An array type\r\n[ICSharpCode.Decompiler.TypeSystem.ArrayType]",
          "Pointer": "A pointer type\r\n[ICSharpCode.Decompiler.TypeSystem.PointerType]",
          "ByReference": "A managed reference type\r\n[ICSharpCode.Decompiler.TypeSystem.ByReferenceType]",
          "Intersection": "Intersection of several types\r\n[ICSharpCode.Decompiler.TypeSystem.IntersectionType]",
          "ArgList": "[ICSharpCode.Decompiler.TypeSystem.SpecialType.ArgList]",
          "Tuple": "A C# 7 tuple type.\r\nE.g. [code](string, int)[/code]\r\nNote: [code]System.ValueTuple\u0026lt;string, int\u0026gt;[/code] is not considered a tuple type.\r\n\r\n[ICSharpCode.Decompiler.TypeSystem.TupleType]",
          "ModOpt": "Modified type, with optional modifier.",
          "ModReq": "Modified type, with required modifier.",
          "NInt": "C# 9 [c]nint[/c]",
          "NUInt": "C# 9 [c]nuint[/c]",
          "FunctionPointer": "C# 9 [c]delegate*[/c]"
        }
      },
      "TypeParameterSubstitution": {
        "Body": "class TypeParameterSubstitution {\n    \u002BCompose(TypeParameterSubstitution g, TypeParameterSubstitution f)$ TypeParameterSubstitution\n    -GetComposedTypeArguments(IReadOnlyList\u2770IType\u2771 input, TypeParameterSubstitution substitution)$ IReadOnlyList\u2770IType\u2771\n    \u002BEquals(TypeParameterSubstitution other, TypeVisitor normalization) bool\n    \u002BEquals(object obj) bool\n    \u002BGetHashCode() int\n    -TypeListEquals(IReadOnlyList\u2770IType\u2771 a, IReadOnlyList\u2770IType\u2771 b)$ bool\n    -TypeListEquals(IReadOnlyList\u2770IType\u2771 a, IReadOnlyList\u2770IType\u2771 b, TypeVisitor normalization)$ bool\n    -TypeListHashCode(IReadOnlyList\u2770IType\u2771 obj)$ int\n    \u002BVisitTypeParameter(ITypeParameter type) IType\n    \u002BVisitNullabilityAnnotatedType(NullabilityAnnotatedType type) IType\n    \u002BToString() string\n    \u002BTypeParameterSubstitution Identity$\n}",
        "BaseType": {
          "TypeVisitor": null
        },
        "Inherited": {
          "TypeVisitor": {
            "FlatMembers": "TypeParameterSubstitution : \u002BVisitTypeDefinition(ITypeDefinition type) IType\nTypeParameterSubstitution : \u002BVisitTypeParameter(ITypeParameter type) IType\nTypeParameterSubstitution : \u002BVisitParameterizedType(ParameterizedType type) IType\nTypeParameterSubstitution : \u002BVisitArrayType(ArrayType type) IType\nTypeParameterSubstitution : \u002BVisitPointerType(PointerType type) IType\nTypeParameterSubstitution : \u002BVisitByReferenceType(ByReferenceType type) IType\nTypeParameterSubstitution : \u002BVisitTupleType(TupleType type) IType\nTypeParameterSubstitution : \u002BVisitOtherType(IType type) IType\nTypeParameterSubstitution : \u002BVisitModReq(ModifiedType type) IType\nTypeParameterSubstitution : \u002BVisitModOpt(ModifiedType type) IType\nTypeParameterSubstitution : \u002BVisitNullabilityAnnotatedType(NullabilityAnnotatedType type) IType\nTypeParameterSubstitution : \u002BVisitFunctionPointerType(FunctionPointerType type) IType"
          }
        },
        "XmlDocs": {
          "": "Substitutes class and method type parameters.",
          "Identity": "The identity function.",
          "ClassTypeArguments": "Gets the list of class type arguments.\r\nReturns [c]null[/c] if this substitution keeps class type parameters unmodified.",
          "MethodTypeArguments": "Gets the list of method type arguments.\r\nReturns [c]null[/c] if this substitution keeps method type parameters unmodified.",
          "Compose": "Computes a single TypeParameterSubstitution so that for all types [c]t[/c]:\r\n[c]t.AcceptVisitor(Compose(g, f)) equals t.AcceptVisitor(f).AcceptVisitor(g)[/c]\r\n\r\n[remarks]If you consider type parameter substitution to be a function, this is function composition.[/remarks]"
        },
        "HasMany": {
          "ClassTypeArguments": "IType",
          "MethodTypeArguments": "IType"
        }
      },
      "TypeProvider": {
        "Body": "class TypeProvider {\n    \u002BGetArrayType(IType elementType, ArrayShape shape) IType\n    \u002BGetByReferenceType(IType elementType) IType\n    \u002BGetFunctionPointerType(MethodSignature\u2770IType\u2771 signature) IType\n    \u002BGetGenericInstantiation(IType genericType, ImmutableArray\u2770IType\u2771 typeArguments) IType\n    \u002BGetGenericMethodParameter(GenericContext genericContext, int index) IType\n    \u002BGetGenericTypeParameter(GenericContext genericContext, int index) IType\n    \u002BGetModifiedType(IType modifier, IType unmodifiedType, bool isRequired) IType\n    \u002BGetPinnedType(IType elementType) IType\n    \u002BGetPointerType(IType elementType) IType\n    \u002BGetPrimitiveType(PrimitiveTypeCode typeCode) IType\n    \u002BGetSystemType() IType\n    \u002BGetSZArrayType(IType elementType) IType\n    -IsReferenceType(MetadataReader reader, EntityHandle handle, byte rawTypeKind) bool?\n    \u002BGetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind) IType\n    \u002BGetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind) IType\n    \u002BGetTypeFromSerializedName(string name) IType\n    \u002BGetTypeFromSpecification(MetadataReader reader, GenericContext genericContext, TypeSpecificationHandle handle, byte rawTypeKind) IType\n    \u002BGetUnderlyingEnumType(IType type) PrimitiveTypeCode\n    \u002BIsSystemType(IType type) bool\n    -MetadataModule module\n}",
        "Interfaces": {
          "ICompilationProvider": [
            null
          ],
          "System_Reflection_Metadata_ISignatureTypeProvider_TType_TGenericContext": [
            "ISignatureTypeProvider\u2770IType, GenericContext\u2771"
          ],
          "System_Reflection_Metadata_ISimpleTypeProvider_TType": [
            "ISimpleTypeProvider\u2770IType\u2771"
          ],
          "System_Reflection_Metadata_IConstructedTypeProvider_TType": [
            "IConstructedTypeProvider\u2770IType\u2771"
          ],
          "System_Reflection_Metadata_ISZArrayTypeProvider_TType": [
            "ISZArrayTypeProvider\u2770IType\u2771"
          ],
          "System_Reflection_Metadata_ICustomAttributeTypeProvider_TType": [
            "ICustomAttributeTypeProvider\u2770IType\u2771"
          ]
        },
        "Inherited": {},
        "XmlDocs": {
          "": "Allows decoding signatures using decompiler types."
        },
        "HasOne": {
          "Compilation": "ICompilation"
        }
      },
      "TypeSystemExtensions": {
        "Body": "class TypeSystemExtensions {\n    \u002BGetAllBaseTypes(IType type)$ IEnumerable\u2770IType\u2771\n    \u002BGetNonInterfaceBaseTypes(IType type)$ IEnumerable\u2770IType\u2771\n    \u002BGetAllBaseTypeDefinitions(IType type)$ IEnumerable\u2770ITypeDefinition\u2771\n    \u002BIsDerivedFrom(ITypeDefinition type, ITypeDefinition baseType)$ bool\n    \u002BIsDerivedFrom(ITypeDefinition type, KnownTypeCode baseType)$ bool\n    \u002BGetDeclaringTypeDefinitions(ITypeDefinition definition)$ IEnumerable\u2770ITypeDefinition\u2771\n    \u002BIsOpen(IType type)$ bool\n    -GetTypeParameterOwner(IType type)$ IEntity\n    \u002BIsUnbound(IType type)$ bool\n    \u002BIsUnmanagedType(IType type, bool allowGenerics)$ bool\n    \u002BIsKnownType(IType type, KnownTypeCode knownType)$ bool\n    ~IsKnownType(IType type, KnownAttribute knownType)$ bool\n    \u002BIsKnownType(FullTypeName typeName, KnownTypeCode knownType)$ bool\n    \u002BIsKnownType(TopLevelTypeName typeName, KnownTypeCode knownType)$ bool\n    ~IsKnownType(FullTypeName typeName, KnownAttribute knownType)$ bool\n    ~IsKnownType(TopLevelTypeName typeName, KnownAttribute knownType)$ bool\n    \u002BGetDelegateInvokeMethod(IType type)$ IMethod\n    \u002BSkipModifiers(IType ty)$ IType\n    \u002BUnwrapByRef(IType type)$ IType\n    \u002BHasReadonlyModifier(IMethod accessor)$ bool\n    \u002BIsAnyPointer(TypeKind typeKind)$ bool\n    \u002BGetAllTypeDefinitions(ICompilation compilation)$ IEnumerable\u2770ITypeDefinition\u2771\n    \u002BGetTopLevelTypeDefinitions(ICompilation compilation)$ IEnumerable\u2770ITypeDefinition\u2771\n    \u002BResolve(IList\u2770ITypeReference\u2771 typeReferences, ITypeResolveContext context)$ IReadOnlyList\u2770IType\u2771\n    \u002BFindType(ICompilation compilation, FullTypeName fullTypeName)$ IType\n    \u002BGetTypeDefinition(IModule module, FullTypeName fullTypeName)$ ITypeDefinition\n    -FindNestedType(ITypeDefinition typeDef, string name, int typeParameterCount)$ ITypeDefinition\n    \u002BHasAttribute(IEntity entity, KnownAttribute attributeType, bool inherit)$ bool\n    \u002BGetAttribute(IEntity entity, KnownAttribute attributeType, bool inherit)$ IAttribute\n    \u002BGetAttributes(IEntity entity, bool inherit)$ IEnumerable\u2770IAttribute\u2771\n    \u002BHasAttribute(IParameter parameter, KnownAttribute attributeType)$ bool\n    \u002BGetAttribute(IParameter parameter, KnownAttribute attributeType)$ IAttribute\n    \u002BGetTypeDefinition(IModule module, string namespaceName, string name, int typeParameterCount)$ ITypeDefinition\n    \u002BGetSymbol(ResolveResult rr)$ ISymbol\n    \u002BGetElementTypeFromIEnumerable(IType collectionType, ICompilation compilation, bool allowIEnumerator, \u0026bool? isGeneric)$ IType\n    \u002BFullNameIs(IMember member, string type, string name)$ bool\n    \u002BIsBuiltinAttribute(ITypeDefinition type)$ KnownAttribute\n    \u002BWithoutNullability(IType type)$ IType\n    \u002BIsDirectImportOf(ITypeDefinition type, IModule module)$ bool\n    \u002BFindModuleByReference(ICompilation compilation, IAssemblyReference assemblyName)$ IModule\n    \u002BAsParameterizedType(ITypeDefinition td)$ IType\n    \u002BGetNamespaceByFullName(ICompilation compilation, string name)$ INamespace\n    \u003C\u003CService\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Contains extension methods for the type system.",
          "GetAllBaseTypes": "Gets all base types.\r\n\r\n[remarks]This is the reflexive and transitive closure of [ICSharpCode.Decompiler.TypeSystem.IType.DirectBaseTypes].\r\nNote that this method does not return all supertypes - doing so is impossible due to contravariance\r\n(and undesirable for covariance as the list could become very large).\r\n\r\nThe output is ordered so that base types occur before derived types.\r\n[/remarks]",
          "GetNonInterfaceBaseTypes": "Gets all non-interface base types.\r\n\r\n[remarks]\r\nWhen [type] is an interface, this method will also return base interfaces (return same output as GetAllBaseTypes()).\r\n\r\nThe output is ordered so that base types occur before derived types.\r\n[/remarks]",
          "GetAllBaseTypeDefinitions": "Gets all base type definitions.\r\nThe output is ordered so that base types occur before derived types.\r\n\r\n[remarks]\r\nThis is equivalent to type.GetAllBaseTypes().Select(t =\u0026gt; t.GetDefinition()).Where(d =\u0026gt; d != null).Distinct().\r\n[/remarks]",
          "IsDerivedFrom": "Gets whether this type definition is derived from a given known type.",
          "GetDeclaringTypeDefinitions": "Returns all declaring type definitions of this type definition.\r\nThe output is ordered so that inner types occur before outer types.",
          "IsOpen": "Gets whether the type is an open type (contains type parameters).\r\n\r\n[example]\r\n[code]\r\nclass X\u0026lt;T\u0026gt; {\r\nList\u0026lt;T\u0026gt; open;\r\nX\u0026lt;X\u0026lt;T[]\u0026gt;\u0026gt; open;\r\nX\u0026lt;string\u0026gt; closed;\r\nint closed;\r\n}\r\n[/code]\r\n[/example]",
          "GetTypeParameterOwner": "Gets the entity that owns the type parameters occurring in the specified type.\r\nIf both class and method type parameters are present, the method is returned.\r\nReturns null if the specified type is closed.\r\n\r\n[seealso cref=\u0022M:ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions.IsOpen(ICSharpCode.Decompiler.TypeSystem.IType)]",
          "IsUnbound": "Gets whether the type is unbound (is a generic type, but no type arguments were provided).\r\n\r\n[remarks]\r\nIn \u0022[c]typeof(List\u0026lt;Dictionary\u0026lt;,\u0026gt;\u0026gt;)[/c]\u0022, only the Dictionary is unbound, the List is considered\r\nbound despite containing an unbound type.\r\nThis method returns false for partially parameterized types ([c]Dictionary\u0026lt;string, \u0026gt;[/c]).\r\n[/remarks]",
          "IsUnmanagedType": "Gets whether the type is considered unmanaged.\r\n\r\n[remarks]\r\nThe C# 6.0 spec lists the following criteria: An unmanaged type is one of the following\r\n* sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, or bool\r\n* any enum type\r\n* any pointer type\r\n* any user-defined struct type that is not a constructed (= generic) type and contains fields of unmanaged types only.\r\n\r\nC# 8.0 removes the restriction that constructed (= generic) types are not considered unmanaged types.\r\n[/remarks]",
          "IsKnownType": "Gets whether the type is the specified known type.\r\nFor generic known types, this returns true for any parameterization of the type (and also for the definition itself).",
          "GetDelegateInvokeMethod": "Gets the invoke method for a delegate type.\r\n\r\n[remarks]\r\nReturns null if the type is not a delegate type; or if the invoke method could not be found.\r\n[/remarks]",
          "GetAllTypeDefinitions": "Gets all type definitions in the compilation.\r\nThis may include types from referenced assemblies that are not accessible in the main assembly.",
          "GetTopLevelTypeDefinitions": "Gets all top level type definitions in the compilation.\r\nThis may include types from referenced assemblies that are not accessible in the main assembly.",
          "FindType": "Retrieves the specified type in this compilation.\r\nReturns an [ICSharpCode.Decompiler.TypeSystem.Implementation.UnknownType] if the type cannot be found in this compilation.\r\n\r\n[remarks]\r\nThere can be multiple types with the same full name in a compilation, as a\r\nfull type name is only unique per assembly.\r\nIf there are multiple possible matches, this method will return just one of them.\r\nWhen possible, use [ICSharpCode.Decompiler.TypeSystem.IModule.GetTypeDefinition(ICSharpCode.Decompiler.TypeSystem.TopLevelTypeName)] instead to\r\nretrieve a type from a specific assembly.\r\n[/remarks]",
          "GetTypeDefinition": "Gets the type definition for a top-level type.\r\n\r\n[remarks]This method uses ordinal name comparison, not the compilation\u0027s name comparer.[/remarks]",
          "HasAttribute": "Gets whether the parameter has an attribute of the specified attribute type.\r\n\r\n[param name=\u0022parameter\u0022]The parameter on which the attributes are declared.[/param]\r\n[param name=\u0022attributeType\u0022]The attribute type to look for.[/param]",
          "GetAttribute": "Gets the attribute of the specified attribute type.\r\n\r\n[param name=\u0022parameter\u0022]The parameter on which the attributes are declared.[/param]\r\n[param name=\u0022attributeType\u0022]The attribute type to look for.[/param]\r\n[returns]\r\nReturns the attribute that was found; or [c]null[/c] if none was found.\r\n[/returns]",
          "GetAttributes": "Gets the attributes on the entity.\r\n\r\n[param name=\u0022entity\u0022]The entity on which the attributes are declared.[/param]\r\n[param name=\u0022inherit\u0022]\r\nSpecifies whether attributes inherited from base classes and base members\r\n(if the given [entity] in an [c]override[/c])\r\nshould be returned.\r\n[/param]\r\n[returns]\r\nReturns the list of attributes that were found.\r\nIf inherit is true, attributes from the entity itself are returned first;\r\nfollowed by attributes inherited from the base entity.\r\n[/returns]",
          "AsParameterizedType": "When given a generic type definition, returns the self-parameterized type\r\n(i.e. the type of \u0022this\u0022 within the type definition).\r\nWhen given a non-generic type definition, returns that definition unchanged."
        }
      },
      "TypeClassificationVisitor": {
        "Name": "TypeSystemExtensions\u002BTypeClassificationVisitor",
        "Body": "class TypeClassificationVisitor {\n    \u002BVisitTypeParameter(ITypeParameter type) IType\n    -GetNestingLevel(IEntity entity)$ int\n    ~bool isOpen\n    ~IEntity typeParameterOwner\n    -int typeParameterOwnerNestingLevel\n}",
        "BaseType": {
          "TypeVisitor": null
        },
        "Inherited": {
          "TypeVisitor": {
            "FlatMembers": "TypeClassificationVisitor : \u002BVisitTypeDefinition(ITypeDefinition type) IType\nTypeClassificationVisitor : \u002BVisitTypeParameter(ITypeParameter type) IType\nTypeClassificationVisitor : \u002BVisitParameterizedType(ParameterizedType type) IType\nTypeClassificationVisitor : \u002BVisitArrayType(ArrayType type) IType\nTypeClassificationVisitor : \u002BVisitPointerType(PointerType type) IType\nTypeClassificationVisitor : \u002BVisitByReferenceType(ByReferenceType type) IType\nTypeClassificationVisitor : \u002BVisitTupleType(TupleType type) IType\nTypeClassificationVisitor : \u002BVisitOtherType(IType type) IType\nTypeClassificationVisitor : \u002BVisitModReq(ModifiedType type) IType\nTypeClassificationVisitor : \u002BVisitModOpt(ModifiedType type) IType\nTypeClassificationVisitor : \u002BVisitNullabilityAnnotatedType(NullabilityAnnotatedType type) IType\nTypeClassificationVisitor : \u002BVisitFunctionPointerType(FunctionPointerType type) IType"
          }
        }
      },
      "TypeSystemOptions": {
        "Body": "class TypeSystemOptions {\n    \u003C\u003CEnumeration\u003E\u003E\n    None\n    Dynamic\n    Tuple\n    ExtensionMethods\n    OnlyPublicAPI\n    Uncached\n    DecimalConstants\n    KeepModifiers\n    ReadOnlyStructsAndParameters\n    RefStructs\n    UnmanagedConstraints\n    NullabilityAnnotations\n    ReadOnlyMethods\n    NativeIntegers\n    FunctionPointers\n    ScopedRef\n    NativeIntegersWithoutAttribute\n    RefReadOnlyParameters\n    Default\n}",
        "XmlDocs": {
          "": "Options that control how metadata is represented in the type system.",
          "None": "No options enabled; stay as close to the metadata as possible.",
          "Dynamic": "[DynamicAttribute] is used to replace \u0027object\u0027 types with the \u0027dynamic\u0027 type.\r\n\r\nIf this option is not active, the \u0027dynamic\u0027 type is not used, and the attribute is preserved.",
          "Tuple": "Tuple types are represented using the TupleType class.\r\n[TupleElementNames] is used to name the tuple elements.\r\n\r\nIf this option is not active, the tuples are represented using their underlying type, and the attribute is preserved.",
          "ExtensionMethods": "If this option is active, [ExtensionAttribute] is removed and methods are marked as IsExtensionMethod.\r\nOtherwise, the attribute is preserved but the methods are not marked.",
          "OnlyPublicAPI": "Only load the public API into the type system.",
          "Uncached": "Do not cache accessed entities.\r\nIn a normal type system (without this option), every type or member definition has exactly one ITypeDefinition/IMember\r\ninstance. This instance is kept alive until the whole type system can be garbage-collected.\r\nWhen this option is specified, the type system avoids these caches.\r\nThis reduces the memory usage in many cases, but increases the number of allocations.\r\nAlso, some code in the decompiler expects to be able to compare type/member definitions by reference equality,\r\nand thus will fail with uncached type systems.",
          "DecimalConstants": "If this option is active, [DecimalConstantAttribute] is removed and constant values are transformed into simple decimal literals.",
          "KeepModifiers": "If this option is active, modopt and modreq types are preserved in the type system.\r\n\r\nNote: the decompiler currently does not support handling modified types;\r\nactivating this option may lead to incorrect decompilation or internal errors.",
          "ReadOnlyStructsAndParameters": "If this option is active, [IsReadOnlyAttribute] on parameters\u002Bstructs is removed\r\nand parameters are marked as in, structs as readonly.\r\nOtherwise, the attribute is preserved but the parameters and structs are not marked.",
          "RefStructs": "If this option is active, [IsByRefLikeAttribute] is removed and structs are marked as ref.\r\nOtherwise, the attribute is preserved but the structs are not marked.",
          "UnmanagedConstraints": "If this option is active, [IsUnmanagedAttribute] is removed from type parameters,\r\nand HasUnmanagedConstraint is set instead.",
          "NullabilityAnnotations": "If this option is active, [NullableAttribute] is removed and reference types with\r\nnullability annotations are used instead.",
          "ReadOnlyMethods": "If this option is active, [IsReadOnlyAttribute] on methods is removed\r\nand the method marked as ThisIsRefReadOnly.",
          "NativeIntegers": "[NativeIntegerAttribute] is used to replace \u0027IntPtr\u0027 types with the \u0027nint\u0027 type.",
          "FunctionPointers": "Allow function pointer types. If this option is not enabled, function pointers are\r\nreplaced with the \u0027IntPtr\u0027 type.",
          "ScopedRef": "Allow C# 11 scoped annotation. If this option is not enabled, ScopedRefAttribute\r\nwill be reported as custom attribute.",
          "NativeIntegersWithoutAttribute": "Replace \u0027IntPtr\u0027 types with the \u0027nint\u0027 type even in absence of [NativeIntegerAttribute].\r\nNote: DecompilerTypeSystem constructor removes this setting from the options if\r\nnot targeting .NET 7 or later.",
          "RefReadOnlyParameters": "If this option is active, [RequiresLocationAttribute] on parameters is removed\r\nand parameters are marked as ref readonly.\r\nOtherwise, the attribute is preserved but the parameters are not marked\r\nas if it was a ref parameter without any attributes.",
          "Default": "Default settings: typical options for the decompiler, with all C# languages features enabled."
        }
      },
      "TypeUtils": {
        "Body": "class TypeUtils {\n    \u002BGetSize(IType type)$ int\n    \u002BGetSize(StackType type)$ int\n    \u002BGetLargerType(IType type1, IType type2)$ IType\n    \u002BIsSmallIntegerType(IType type)$ bool\n    \u002BIsCSharpSmallIntegerType(IType type)$ bool\n    \u002BIsCSharpNativeIntegerType(IType type)$ bool\n    \u002BIsCSharpPrimitiveIntegerType(IType type)$ bool\n    \u002BIsIntegerType(StackType type)$ bool\n    \u002BIsFloatType(StackType type)$ bool\n    \u002BIsCompatiblePointerTypeForMemoryAccess(IType pointerType, IType accessType)$ bool\n    \u002BIsCompatibleTypeForMemoryAccess(IType memoryType, IType accessType)$ bool\n    \u002BGetStackType(IType type)$ StackType\n    \u002BGetEnumUnderlyingType(IType type)$ IType\n    \u002BGetSign(IType type)$ Sign\n    \u002BToPrimitiveType(KnownTypeCode knownTypeCode)$ PrimitiveType\n    \u002BToPrimitiveType(IType type)$ PrimitiveType\n    \u002BToKnownTypeCode(PrimitiveType primitiveType)$ KnownTypeCode\n    \u002BToKnownTypeCode(StackType stackType, Sign sign)$ KnownTypeCode\n    \u002BToPrimitiveType(StackType stackType, Sign sign)$ PrimitiveType\n    \u002Bint NativeIntSize$\n    \u003C\u003CService\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "GetSize": "Gets the size of the input stack type.\r\n\r\n[returns]\r\n* 4 for [c]I4[/c],\r\n* 8 for [c]I8[/c],\r\n* [c]NativeIntSize[/c] for [c]I[/c] and [c]Ref[/c],\r\n* 0 otherwise (O, F, Void, Unknown).\r\n[/returns]",
          "IsSmallIntegerType": "Gets whether the type is a small integer type.\r\nSmall integer types are:\r\n* bool, sbyte, byte, char, short, ushort\r\n* any enums that have a small integer type as underlying type",
          "IsCSharpSmallIntegerType": "Gets whether the type is a C# small integer type: byte, sbyte, short or ushort.\r\n\r\nUnlike the ILAst, C# does not consider bool, char or enums to be small integers.",
          "IsCSharpNativeIntegerType": "Gets whether the type is a C# 9 native integer type: nint or nuint.\r\n\r\nReturns false for (U)IntPtr.",
          "IsCSharpPrimitiveIntegerType": "Gets whether the type is a C# primitive integer type: byte, sbyte, short, ushort, int, uint, long and ulong.\r\n\r\nUnlike the ILAst, C# does not consider bool, enums, pointers or IntPtr to be integers.",
          "IsIntegerType": "Gets whether the type is an IL integer type.\r\nReturns true for I4, I, or I8.",
          "IsFloatType": "Gets whether the type is an IL floating point type.\r\nReturns true for F4 or F8.",
          "IsCompatiblePointerTypeForMemoryAccess": "Gets whether reading/writing an element of accessType from the pointer\r\nis equivalent to reading/writing an element of the pointer\u0027s element type.\r\n\r\n[remarks]\r\nThe access semantics may sligthly differ on read accesses of small integer types,\r\ndue to zero extension vs. sign extension when the signs differ.\r\n[/remarks]",
          "IsCompatibleTypeForMemoryAccess": "Gets whether reading/writing an element of accessType from the pointer\r\nis equivalent to reading/writing an element of the memoryType.\r\n\r\n[remarks]\r\nThe access semantics may sligthly differ on read accesses of small integer types,\r\ndue to zero extension vs. sign extension when the signs differ.\r\n[/remarks]",
          "GetStackType": "Gets the stack type corresponding to this type.",
          "GetEnumUnderlyingType": "If type is an enumeration type, returns the underlying type.\r\nOtherwise, returns type unmodified.",
          "GetSign": "Gets the sign of the input type.\r\n\r\n[remarks]\r\nInteger types (including IntPtr/UIntPtr) return the sign as expected.\r\nFloating point types and [c]decimal[/c] are considered to be signed.\r\n[c]char[/c], [c]bool[/c] and pointer types (e.g. [c]void*[/c]) are unsigned.\r\nEnums have a sign based on their underlying type.\r\nAll other types return [c]Sign.None[/c].\r\n[/remarks]",
          "ToPrimitiveType": "Maps the KnownTypeCode values to the corresponding PrimitiveTypes.",
          "ToKnownTypeCode": "Maps the PrimitiveType values to the corresponding KnownTypeCodes."
        }
      },
      "TypeVisitor": {
        "Body": "class TypeVisitor {\n    \u002BVisitTypeDefinition(ITypeDefinition type) IType\n    \u002BVisitTypeParameter(ITypeParameter type) IType\n    \u002BVisitParameterizedType(ParameterizedType type) IType\n    \u002BVisitArrayType(ArrayType type) IType\n    \u002BVisitPointerType(PointerType type) IType\n    \u002BVisitByReferenceType(ByReferenceType type) IType\n    \u002BVisitTupleType(TupleType type) IType\n    \u002BVisitOtherType(IType type) IType\n    \u002BVisitModReq(ModifiedType type) IType\n    \u002BVisitModOpt(ModifiedType type) IType\n    \u002BVisitNullabilityAnnotatedType(NullabilityAnnotatedType type) IType\n    \u002BVisitFunctionPointerType(FunctionPointerType type) IType\n    \u003C\u003CAbstract\u003E\u003E\n}",
        "Inherited": {},
        "XmlDocs": {
          "": "Base class for the visitor pattern on [ICSharpCode.Decompiler.TypeSystem.IType]."
        }
      },
      "VarArgInstanceMethod": {
        "Body": "class VarArgInstanceMethod {\n    \u002Bint RegularParameterCount\n    -bool ICSharpCode.Decompiler.TypeSystem.IMethod.ReturnTypeIsRefReadOnly\n    -bool ICSharpCode.Decompiler.TypeSystem.IMethod.ThisIsRefReadOnly\n    -bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsInitOnly\n    \u002BEntityHandle MetadataToken\n    \u002Bbool IsExtensionMethod\n    -bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsLocalFunction\n    \u002Bbool IsConstructor\n    \u002Bbool IsDestructor\n    \u002Bbool IsOperator\n    \u002Bbool HasBody\n    \u002Bbool IsAccessor\n    \u002BMethodSemanticsAttributes AccessorKind\n    \u002Bbool IsExplicitInterfaceImplementation\n    \u002Bbool IsVirtual\n    \u002Bbool IsOverride\n    \u002Bbool IsOverridable\n    \u002Bstring Name\n    \u002Bbool IsStatic\n    \u002Bbool IsAbstract\n    \u002Bbool IsSealed\n    \u002Bstring FullName\n    \u002Bstring ReflectionName\n    \u002Bstring Namespace\n    \u002BEquals(object obj) bool\n    \u002BGetHashCode() int\n    \u002BEquals(IMember obj, TypeVisitor typeNormalization) bool\n    \u002BToString() string\n    \u002BSpecialize(TypeParameterSubstitution substitution) IMethod\n    -IEntity.GetAttributes() IEnumerable\u2770IAttribute\u2771\n    -IEntity.HasAttribute(KnownAttribute attribute) bool\n    -IEntity.GetAttribute(KnownAttribute attribute) IAttribute\n    -IMethod.GetReturnTypeAttributes() IEnumerable\u2770IAttribute\u2771\n    -IMember.Specialize(TypeParameterSubstitution substitution) IMember\n    -IParameter[] parameters\n}",
        "Interfaces": {
          "IMethod": [
            null
          ],
          "IParameterizedMember": [
            null
          ],
          "IMember": [
            null
          ],
          "IEntity": [
            null
          ],
          "ISymbol": [
            null
          ],
          "ICompilationProvider": [
            null
          ],
          "INamedElement": [
            null
          ]
        },
        "Inherited": {},
        "XmlDocs": {
          "": "Used when calling a vararg method. Stores the actual parameter types being passed."
        },
        "HasOne": {
          "BaseMethod": "IMethod",
          "AccessorOwner": "IMember",
          "ReducedFrom": "IMethod",
          "MemberDefinition": "IMember",
          "ReturnType": "IType",
          "Substitution": "TypeParameterSubstitution",
          "SymbolKind": "SymbolKind",
          "DeclaringTypeDefinition": "ITypeDefinition",
          "DeclaringType": "IType",
          "ParentModule": "IModule",
          "Accessibility": "Accessibility",
          "Compilation": "ICompilation"
        },
        "HasMany": {
          "Parameters": "IParameter",
          "TypeParameters": "ITypeParameter",
          "TypeArguments": "IType",
          "ExplicitlyImplementedInterfaceMembers": "IMember"
        }
      },
      "VarianceModifier": {
        "Body": "class VarianceModifier {\n    \u003C\u003CEnumeration\u003E\u003E\n    Invariant\n    Covariant\n    Contravariant\n}",
        "XmlDocs": {
          "": "Represents the variance of a type parameter.",
          "Invariant": "The type parameter is not variant.",
          "Covariant": "The type parameter is covariant (used in output position).",
          "Contravariant": "The type parameter is contravariant (used in input position)."
        }
      }
    }
  }
}</script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.4.0/dist/mermaid.min.js"></script>
    <script src="script.js"></script>
</body>
</html>
